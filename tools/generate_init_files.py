#!/usr/bin/env python3
"""
Generate __init__.py files for OpenSearch Protobufs Python package.

This script automatically extracts class names from generated protobuf files
and creates __init__.py files that re-export all classes without requiring
knowledge of specific _pb2 file names.
"""

import os
import sys
import re
from pathlib import Path


def extract_classes_from_pb2_file(file_path):
    """Extract class names from a _pb2.py file by importing it."""
    classes = []
    enums = []
    constants = []

    try:
        # Get the module name from the file path
        # e.g., /path/to/schemas/document_pb2.py -> schemas.document_pb2
        file_path_str = str(file_path)
        path_parts = file_path_str.replace('.py', '').split('/')

        # Find the part after 'opensearch/protobufs'
        try:
            opensearch_idx = path_parts.index('opensearch')
            protobufs_idx = path_parts.index('protobufs', opensearch_idx)
            module_parts = path_parts[opensearch_idx:protobufs_idx+1] + path_parts[protobufs_idx+1:]
            module_name = '.'.join(module_parts)
        except (ValueError, IndexError):
            # Fallback: assume it's in the current directory structure
            module_name = f"opensearch.protobufs.{path_parts[-2]}.{path_parts[-1]}"

        # Import the module
        import importlib.util
        spec = importlib.util.spec_from_file_location(module_name, file_path)
        if spec is None or spec.loader is None:
            print(f"Warning: Could not load spec for {file_path}")
            return classes, enums, constants

        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Extract all public classes, enums, and constants
        for name in dir(module):
            if name.startswith('_') or name == 'DESCRIPTOR':
                continue

            obj = getattr(module, name)

            # Check if it's a protobuf message class (has DESCRIPTOR and is a type)
            if (hasattr(obj, 'DESCRIPTOR') and
                hasattr(obj, '__module__') and
                str(type(obj)).find('MessageMeta') != -1):
                classes.append(name)
            # Check if it's an enum type
            elif (hasattr(obj, 'DESCRIPTOR') and
                  str(type(obj)).find('EnumTypeWrapper') != -1):
                enums.append(name)
            # Check if it's a constant (int with uppercase name)
            elif isinstance(obj, int) and name.isupper() and '_' in name:
                constants.append(name)

    except Exception as e:
        print(f"Warning: Could not import {file_path}: {e}")
        # Fallback to simple inspection if import fails
        try:
            with open(file_path, 'r') as f:
                content = f.read()
            # Look for class definitions in __all__ if it exists
            all_pattern = r'__all__\s*=\s*\[(.*?)\]'
            all_match = re.search(all_pattern, content, re.DOTALL)
            if all_match:
                all_items = re.findall(r"'([^']+)'", all_match.group(1))
                classes.extend([item for item in all_items if item[0].isupper() and not item.startswith('_')])
        except Exception as e2:
            print(f"Warning: Fallback parsing also failed for {file_path}: {e2}")

    return sorted(set(classes)), sorted(set(enums)), sorted(set(constants))


def generate_schemas_init(schemas_dir, output_file):
    """Generate __init__.py for schemas package."""
    all_classes = []
    all_enums = []
    all_constants = []

    # Find all _pb2.py files in schemas directory
    pb2_files = []
    for file_path in Path(schemas_dir).glob("*_pb2.py"):
        pb2_files.append(file_path)
        classes, enums, constants = extract_classes_from_pb2_file(file_path)
        all_classes.extend(classes)
        all_enums.extend(enums)
        all_constants.extend(constants)

    # Remove duplicates and sort
    all_classes = sorted(set(all_classes))
    all_enums = sorted(set(all_enums))
    all_constants = sorted(set(all_constants))

    # Generate the __init__.py content
    content = '''# OpenSearch Protobuf Schemas
# This module provides convenient access to all protobuf message types
# without requiring knowledge of the specific _pb2 module names.
#
# This file is automatically generated by tools/generate_init_files.py
# DO NOT EDIT MANUALLY

# Import all classes from the generated modules
'''

    # Add imports for each _pb2 file
    for pb2_file in sorted(pb2_files):
        module_name = pb2_file.stem  # e.g., "document_pb2"
        content += f"from .{module_name} import *\n"

    content += '''
# Re-export all discovered classes for convenience
__all__ = [
'''

    # Add all classes to __all__
    all_exports = []
    if all_classes:
        content += "    # Message types\n"
        for cls in all_classes:
            all_exports.append(cls)
            content += f"    '{cls}',\n"

    if all_enums:
        content += "    # Enum types\n"
        for enum in all_enums:
            all_exports.append(enum)
            content += f"    '{enum}',\n"

    if all_constants:
        content += "    # Enum constants\n"
        for const in all_constants[:50]:  # Limit to avoid too many constants
            all_exports.append(const)
            content += f"    '{const}',\n"
        if len(all_constants) > 50:
            content += "    # ... and more enum constants\n"

    content += "]\n"

    # Write the file
    with open(output_file, 'w') as f:
        f.write(content)

    print(f"Generated {output_file} with {len(all_exports)} exports")
    return all_exports


def generate_services_init(services_dir, output_file):
    """Generate __init__.py for services package."""
    all_classes = []

    # Find all _pb2.py and _pb2_grpc.py files
    pb2_files = []
    grpc_files = []

    for file_path in Path(services_dir).glob("*_pb2.py"):
        if not file_path.name.endswith("_grpc.py"):
            pb2_files.append(file_path)

    for file_path in Path(services_dir).glob("*_pb2_grpc.py"):
        grpc_files.append(file_path)

    # Generate the __init__.py content
    content = '''# OpenSearch Protobuf Services
# This module provides convenient access to all gRPC service stubs
# without requiring knowledge of the specific _pb2 module names.
#
# This file is automatically generated by tools/generate_init_files.py
# DO NOT EDIT MANUALLY

# Import all classes from the generated service modules
'''

    # Add imports
    for pb2_file in sorted(pb2_files):
        module_name = pb2_file.stem
        content += f"from .{module_name} import *\n"

    for grpc_file in sorted(grpc_files):
        module_name = grpc_file.stem
        content += f"from .{module_name} import *\n"

    # For services, we'll use a simpler approach since the main classes are predictable
    content += '''
# Re-export the service stubs for convenience
__all__ = [
    # Document service
    'DocumentServiceStub',
    'DocumentServiceServicer',
    'add_DocumentServiceServicer_to_server',

    # Search service
    'SearchServiceStub',
    'SearchServiceServicer',
    'add_SearchServiceServicer_to_server',
]
'''

    # Write the file
    with open(output_file, 'w') as f:
        f.write(content)

    print(f"Generated {output_file}")


def main():
    if len(sys.argv) != 3:
        print("Usage: generate_init_files.py <schemas_dir> <services_dir>")
        sys.exit(1)

    schemas_dir = sys.argv[1]
    services_dir = sys.argv[2]

    # Generate schemas __init__.py
    schemas_init = os.path.join(schemas_dir, "__init__.py")
    generate_schemas_init(schemas_dir, schemas_init)

    # Generate services __init__.py
    services_init = os.path.join(services_dir, "__init__.py")
    generate_services_init(services_dir, services_init)

    # Generate parent __init__.py files
    protobufs_dir = os.path.dirname(schemas_dir)
    if protobufs_dir and os.path.basename(protobufs_dir) == "protobufs":
        protobufs_init = os.path.join(protobufs_dir, "__init__.py")
        with open(protobufs_init, 'w') as f:
            f.write("# OpenSearch Protobufs\n")

        opensearch_dir = os.path.dirname(protobufs_dir)
        if opensearch_dir and os.path.basename(opensearch_dir) == "opensearch":
            opensearch_init = os.path.join(opensearch_dir, "__init__.py")
            with open(opensearch_init, 'w') as f:
                f.write("# OpenSearch Protobufs Python Package\n")

    print("âœ… All __init__.py files generated successfully!")


if __name__ == "__main__":
    main()
