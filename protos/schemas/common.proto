/**
This is generated from the spec. DO NOT manually modify.
*/
syntax = "proto3";

option java_multiple_files = true;
option java_package = "org.opensearch.protobufs";
option java_outer_classname = "CommonProto";
option go_package = "opensearchpb";

import "google/protobuf/struct.proto";

message WaitForActiveShards {

  enum WaitForActiveShardOptions {
    WAIT_FOR_ACTIVE_SHARD_OPTIONS_UNSPECIFIED = 0;
    WAIT_FOR_ACTIVE_SHARD_OPTIONS_ALL = 1;
  }

  oneof wait_for_active_shards {
    int32 int32_value = 1;
    WaitForActiveShardOptions wait_for_active_shard_options = 2;
  }

}

message Script {
  oneof script {
    // Defines an inline script to execute as part of a query.
    InlineScript inline_script = 1;
    // References a stored script by its ID for use in a query.
    StoredScriptId stored_script_id = 2;
  }
}

message InlineScript {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;

  // [optional]
  // The script's language. Default is painless.
  ScriptLanguage lang = 2;

  map<string, string> options = 3;

  // [required]
  // The script source.
  string source = 4;
}

message ScriptLanguage {
  enum BuiltinScriptLanguage {
    BUILTIN_SCRIPT_LANGUAGE_UNSPECIFIED = 0;
    BUILTIN_SCRIPT_LANGUAGE_EXPRESSION = 1;
    BUILTIN_SCRIPT_LANGUAGE_JAVA = 2;
    BUILTIN_SCRIPT_LANGUAGE_MUSTACHE = 3;
    BUILTIN_SCRIPT_LANGUAGE_PAINLESS = 4;
  }
  // [optional] Default is painless.
  oneof script_language {
    BuiltinScriptLanguage builtin_script_language = 1;
    string string_value = 2;
  }
}

message StoredScriptId {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;
  // [required]
  // The ID of a stored script previously created using the Create Stored Script API.
  string id = 2;
}

message ObjectMap {
  map<string, Value> fields = 1;

  message Value {
    oneof value {
      NullValue null_value = 1;
      int32 int32 = 2;
      int64 int64 = 3;
      float float = 4;
      double double = 5;
      string string = 6;
      bool bool = 7;
      ObjectMap object_map = 8;
      ListValue list_value = 9;
    }
  }
  
  // `ListValue` is a wrapper around a repeated field of values.
  // The JSON representation for `ListValue` is JSON array.
  message ListValue {
    // Repeated field of dynamically typed values.
    repeated Value value = 1;
  }
}

enum NullValue {
  NULL_VALUE_UNSPECIFIED = 0;
  NULL_VALUE_NULL = 1;
}

// [optional] Controls how document source fields are returned in the response.
// - If not set, source is returned as bytes (default, recommended for better performance)
// - If set to SOURCE_TYPE_STRUCT: source is returned as a structured protobuf message
enum SourceType {
  SOURCE_TYPE_UNSPECIFIED = 0;
  SOURCE_TYPE_STRUCT = 1;
}

message GeoLocation {

  oneof geo_location {
    LatLonGeoLocation lat_lon_geo_location = 1;
    GeoHashLocation geo_hash_location = 2;
    NumberArray number_array = 3;
  }

}

message NumberArray {

  repeated double number_array = 1;

}

message LatLonGeoLocation {
  // Latitude
  double lat = 1;

  // Longitude
  double lon = 2;

}

message GeoHashLocation {

  string geohash = 1;

}

message GeneralNumber {
  oneof value{
    int32 int32_value = 1;
    int64 int64_value = 2;
    float float_value = 3;
    double double_value = 4;
  }
}

message SourceConfigParam {

  oneof source_config_param {
    // `true` or `false` to return the `_source` field or not
    bool bool_value = 1;
    // list of fields to be retrieved from `_source`
    StringArray string_array = 2;
  }

}

message StringArray{
  repeated string string_array = 1;
}

message StringOrStringArray {
  oneof string_or_string_array{
    string string_value = 1;
    StringArray string_array = 2;
  }
}

message SourceConfig {

  oneof source_config{
    // [optional] if the source_config is bool value. true: The entire document source is returned. false: The document source is not returned.
    bool fetch = 1;
    // [optional] Array of patterns containing source fields to return.
    StringArray includes = 2;
    // [optional] source_filter type containing a list of source fields to include or exclude.
    SourceFilter filter = 3;
  }

}

message RuntimeField {

  // For type `lookup`
  repeated RuntimeFieldFetchFields fetch_fields = 1;

  // A custom format for `date` type runtime fields.
  string format = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string input_field = 3;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string target_field = 4;

  string target_index = 5;

  Script script = 6;

  enum RuntimeFieldType {
    RUNTIME_FIELD_TYPE_UNSPECIFIED = 0;
    RUNTIME_FIELD_TYPE_BOOLEAN = 1;
    RUNTIME_FIELD_TYPE_DATE = 2;
    RUNTIME_FIELD_TYPE_DOUBLE = 3;
    RUNTIME_FIELD_TYPE_GEO_POINT = 4;
    RUNTIME_FIELD_TYPE_IP = 5;
    RUNTIME_FIELD_TYPE_KEYWORD = 6;
    RUNTIME_FIELD_TYPE_LONG = 7;
    RUNTIME_FIELD_TYPE_LOOKUP = 8;
  }

  RuntimeFieldType type = 7;

}

message RuntimeFieldFetchFields {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  string format = 2;

}

message SourceFilter {
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to exclude from the response.
  repeated string excludes = 1;
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to return.
  repeated string includes = 2;
}

message ErrorCause {

  // The type of error
  optional string type = 1;

  // A human-readable explanation of the error, in english
  optional string reason = 2;

  // The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.
  optional string stack_trace = 3;

  optional ErrorCause caused_by = 4;

  repeated ErrorCause root_cause = 5;

  repeated ErrorCause suppressed = 6;

  optional string index = 7;

  optional string shard = 8;

  optional string index_uuid = 9;

  // [optional] The spec actually does not have a field named 'metadata'. This should have adaptor_unnest. 
  map<string, ObjectMap.Value> metadata = 10;

  // [optional] 
  map<string, StringOrStringArray> header = 11;
}
message ShardStatistics {
  // [required] Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having failed+successful less than total is thus an indication that some of the shards were not allocated.
  int32 failed = 1;

  // [required] Number of shards that executed the request successfully.
  int32 successful = 2;

  // [required] Total number of shards that require querying, including unallocated shards.
  int32 total = 3;

  // [optional] An array of any shard-specific failures that occurred during the search operation.
  repeated ShardFailure failures = 4;

  // [optional] Number of shards that skipped the request because a lightweight check helped realize that no documents could possibly match on this shard. This typically happens when a search request includes a range filter and the shard only has values that fall outside of that range.
  int32 skipped = 5;

}

message ShardInfo {
  // [required] Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having failed+successful less than total is thus an indication that some of the shards were not allocated.
  int32 failed = 1;

  // [required] Number of shards that executed the request successfully.
  int32 successful = 2;

  // [required] Total number of shards that require querying, including unallocated shards.
  int32 total = 3;

  // [optional] An array of any shard-specific failures that occurred during the search operation.
  repeated ShardFailure failures = 4;

}

message ShardFailure {

  // [optional] Name of the index in which the shard failure occurred.
  optional string index = 1;

  // [optional] ID of the node where the shard is located.
  optional string node = 2;

  // [required] Provides details about the error that caused the shard failure.
  ErrorCause reason = 3;

  // [required] The shard number where the failure occurred.
  int32 shard = 4;

  // [optional] Error status.
  optional string status = 5;

  // [required]
  bool primary = 6;

}

message ShardSearchFailure {

  // [optional] Name of the index in which the shard failure occurred.
  optional string index = 1;

  // [optional] ID of the node where the shard is located.
  optional string node = 2;

  // [required] Provides details about the error that caused the shard failure.
  ErrorCause reason = 3;

  // [required] The shard number where the failure occurred.
  int32 shard = 4;

  // [optional] Error status.
  optional string status = 5;
}

// The fields in this message are effectively oneOf
message QueryContainer {

  // [optional]
  // A Boolean (bool) query can combine several query clauses into one advanced query. The clauses are combined with Boolean logic to find matching documents returned in the results.
  // If provided, no other fields should be provided inside QueryContainer
  optional BoolQuery bool = 1;

  // [optional]
  // A boosting query returns documents that match a positive query. Among those documents, the ones that also match the negative query are scored lower in relevance (their relevance score is multiplied by the negative boosting factor).
  // If provided, no other fields should be provided inside QueryContainer
  optional BoostingQuery boosting = 2;

  // [optional]
  // A constant_score query wraps a filter query and assigns all documents in the results a relevance score equal to the value of the boost parameter.
  // If provided, no other fields should be provided inside QueryContainer
  optional ConstantScoreQuery constant_score = 3;

  // [optional]
  // A disjunction max (dis_max) query returns any document that matches one or more query clauses. For documents that match multiple query clauses, the relevance score is set to the highest relevance score from all matching query clauses.
  // If provided, no other fields should be provided inside QueryContainer
  optional DisMaxQuery dis_max = 4;

  // [optional]
  // Use a function_score query if you need to alter the relevance scores of documents returned in the results. A function_score query defines a query and one or more functions that can be applied to all results or subsets of the results to recalculate their relevance scores.
  // If provided, no other fields should be provided inside QueryContainer
  FunctionScoreQuery function_score = 5;

  // [optional]
  // Use the exists query to search for documents that contain a specific field.
  // If provided, no other fields should be provided inside QueryContainer
  optional ExistsQuery exists = 6;

  // [optional]
  // Fuzzy query is to searches for documents containing terms that are similar to the search term within the maximum allowed Damerau–Levenshtein distance. The Damerau–Levenshtein distance measures the number of one-character changes needed to change one term to another term.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, FuzzyQuery> fuzzy = 7;

  // [optional]
  // Use the ids query to search for documents with one or more specific document ID values in the _id field. For example, the following query requests documents with the IDs 34229 and 91296.
  // If provided, no other fields should be provided inside QueryContainer
  optional IdsQuery ids = 8;

  // [optional]
  // Prefix query is to search for terms that begin with a specific prefix.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, PrefixQuery> prefix = 9;

  // [optional]
  // Returns documents that contain terms within a provided range.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, RangeQuery> range = 10;

  // [optional]
  // Returns documents that contain terms matching a regular expression.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, RegexpQuery> regexp = 11;

  // [optional]
  // Term query is to search for an exact term in a field. The term query does not analyze the search term. The term query only searches for the exact term you provide.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, TermQuery> term = 12;

  // [optional]
  // Terms query field is to search for documents containing one or more terms in a specific field. Use the terms query to search for multiple terms in the same field.
  // If provided, no other fields should be provided inside QueryContainer
  optional TermsQueryField terms = 13;

  // [optional]
  // terms set query is to search for documents that match a minimum number of exact terms in a specified field. A terms_set query is similar to a terms query, except that you can specify the minimum number of matching terms that are required in order to return a document. You can specify this number either in a field in the index or with a script.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, TermsSetQuery> terms_set = 14;

  // [optional]
  // Returns documents that contain terms matching a wildcard pattern.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, WildcardQuery> wildcard = 15;

  // [optional]
  // Use the match query for full-text search on a specific document field. If you run a match query on a text field, the match query analyzes the provided search string and returns documents that match any of the string's terms. If you run a match query on an exact-value field, it returns documents that match the exact value. The preferred way to search exact-value fields is to use a filter because, unlike a query, a filter is cached.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, MatchQueryTypeless> match = 16;

  // [optional]
  // The match_bool_prefix query analyzes the provided search string and creates a Boolean query from the string's terms. It uses every term except the last term as a whole word for matching. The last term is used as a prefix. The match_bool_prefix query returns documents that contain either the whole-word terms or terms that start with the prefix term, in any order.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, MatchBoolPrefixQuery> match_bool_prefix = 17;

  // [optional]
  // Use the match_phrase query to match documents that contain an exact phrase in a specified order. You can add flexibility to phrase matching by providing the slop parameter.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, MatchPhraseQuery> match_phrase = 18;

  // [optional]
  // Use the match_phrase_prefix query to specify a phrase to match in order. The documents that contain the phrase you specify will be returned. The last partial term in the phrase is interpreted as a prefix, so any documents that contain phrases that begin with the phrase and prefix of the last term will be returned.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, MatchPhrasePrefixQuery> match_phrase_prefix = 19;

  // [optional]
  // A multi-match operation functions similarly to the match operation. You can use a multi_match query to search multiple fields.
  // If provided, no other fields should be provided inside QueryContainer
  MultiMatchQuery multi_match = 20;

  // [optional]
  // A query_string query parses the query string based on the query string syntax. It provides for creating powerful yet concise queries that can incorporate wildcards and search multiple fields.
  // If provided, no other fields should be provided inside QueryContainer
  optional QueryStringQuery query_string = 21;

  // [optional]
  // Use the simple_query_string type to specify multiple arguments delineated by regular expressions directly in the query string. Simple query string has a less strict syntax than query string because it discards any invalid portions of the string and does not return errors for invalid syntax.
  // If provided, no other fields should be provided inside QueryContainer
  optional SimpleQueryStringQuery simple_query_string = 22;

  // [optional]
  // Returns documents based on the order and proximity of matching terms.
  // If provided, no other fields should be provided inside QueryContainer
  // Only 1 entry can be provided in the map
  map<string, IntervalsQuery> intervals = 23;

  // [optional]
  // Knn query is to search for the k-nearest neighbors to a query point across an index of vectors. To determine the neighbors, you can specify the space (the distance function) you want to use to measure the distance between points.
  // If provided, no other fields should be provided inside QueryContainer
  optional KnnQuery knn = 24;

  // [optional]
  // The match all query returns all documents. This query can be useful in testing large document sets if you need to return the entire set.
  // If provided, no other fields should be provided inside QueryContainer
  optional MatchAllQuery match_all = 25;

  // [optional]
  // This is the inverse of the match_all query, which matches no documents.
  // If provided, no other fields should be provided inside QueryContainer
  optional MatchNoneQuery match_none = 26;

  // [optional]
  // Use a script_score query to customize the score calculation by using a script. For an expensive scoring function, you can use a script_score query to calculate the score only for the returned documents that have been filtered.
  // If provided, no other fields should be provided inside QueryContainer
  optional ScriptScoreQuery script_score = 27;

  // [optional]
  // The nested query acts as a wrapper for other queries to search nested fields. The nested field objects are searched as though they were indexed as separate documents. If an object matches the search, the nested query returns the parent document at the root level.
  // If provided, no other fields should be provided inside QueryContainer
  optional NestedQuery nested = 28;

}

message NestedQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // Set to `true` to ignore an unmapped field and not match any documents for this query. Set to `false` to throw an exception if the field is not mapped.
  bool ignore_unmapped = 3;

  InnerHits inner_hits = 4;

  // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  string path = 5;

  QueryContainer query = 6;

  enum ChildScoreMode {
    CHILD_SCORE_MODE_UNSPECIFIED = 0;
    CHILD_SCORE_MODE_AVG = 1;
    CHILD_SCORE_MODE_MAX = 2;
    CHILD_SCORE_MODE_MIN = 3;
    CHILD_SCORE_MODE_NONE = 4;
    CHILD_SCORE_MODE_SUM = 5;
  }
  ChildScoreMode score_mode = 7;

}

message InnerHits {

  // [optional] The name to be used for the particular inner hit definition in the response. Useful when multiple inner hits have been defined in a single search request.
  optional string name = 1;

  // [optional] The maximum number of hits to return per `inner_hits`.
  optional int32 size = 2;

  // [optional] Inner hit starting document offset.
  optional int32 from = 3;

  // [optional] The collapse parameter groups search results by a particular field value. This returns only the top document within each group, which helps reduce redundancy by eliminating duplicates.
  optional FieldCollapse collapse = 4;

  // [optional] The fields that OpenSearch should return using their docvalue forms. Specify a format to return results in a certain format, such as date and time.
  repeated FieldAndFormat docvalue_fields = 5;

  // [optional] Whether to return details about how OpenSearch computed the document's score. Default is false.
  optional bool explain = 6;

  // [optional] Highlighting emphasizes the search term(s) in the results so you can emphasize the query matches.
  optional Highlight highlight = 7;

  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  optional bool ignore_unmapped = 8;

  // [optional] The script_fields parameter allows you to include custom fields whose values are computed using scripts in your search results. This can be useful for calculating values dynamically based on the document data. You can also retrieve derived fields by using a similar approach.
  map<string, ScriptField> script_fields = 9;

  // [optional] Whether to return sequence number and primary term of the last operation of each document hit.
  optional bool seq_no_primary_term = 10;

  // [optional] Retrieve selected fields from a search
  repeated FieldAndFormat fields = 11;

  // [optional] How the inner hits should be sorted per inner_hits. By default the hits are sorted by the score.
  repeated SortCombinations sort = 12;

  // [optional] Select what fields of the source are returned
  optional SourceConfig source = 13 [json_name = "_source"];

  // [optional] A list of stored fields to return as part of a hit. If no fields are specified, no stored fields are included in the response. If this option is specified, the _source parameter defaults to false. You can pass _source: true to return both source fields and stored fields in the search response.
  repeated string stored_fields = 14;

  // [optional] Whether to return document scores. Default is false.
  optional bool track_scores = 15;

  // [optional] Whether to include the document version as a match.
  optional bool version = 16;

}

message ScriptField {
  Script script = 1;
  optional bool ignore_failure = 2;
}

message Highlight {

  enum HighlighterType {
    HIGHLIGHTER_TYPE_UNSPECIFIED = 0;
    // The fvh highlighter uses the Lucene Fast Vector highlighter. This highlighter can be used on fields with term_vector set to with_positions_offsets in the mapping.
    HIGHLIGHTER_TYPE_FVH = 1;
    // The plain highlighter uses the standard Lucene highlighter. It attempts to reflect the query matching logic in terms of understanding word importance and any word positioning criteria in phrase queries.
    HIGHLIGHTER_TYPE_PLAIN = 2;
    // The unified highlighter uses the Lucene Unified Highlighter. This highlighter breaks the text into sentences and uses the BM25 algorithm to score individual sentences as if they were documents in the corpus. It also supports accurate phrase and multi-term (fuzzy, prefix, regex) highlighting. The unified highlighter can combine matches from multiple fields into one result (see matched_fields). This is the default highlighter.
    HIGHLIGHTER_TYPE_UNIFIED = 3;
  }

  // [optional] Specifies the highlighter to use. Default is unified.
  optional HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  optional string boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  optional int32 boundary_max_scan = 3;

  enum BoundaryScanner {
    BOUNDARY_SCANNER_UNSPECIFIED = 0;
    // Split highlighted fragments at any character listed in boundary_chars. Valid only for the fvh highlighter.
    BOUNDARY_SCANNER_CHARS = 1;
    // Split highlighted fragments at sentence boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_SENTENCE = 2;
    // Split highlighted fragments at word boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_WORD = 3;
  }

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  optional BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  optional string boundary_scanner_locale = 5;

  // [x-deprecated]
  optional bool force_source = 6;

  enum HighlighterFragmenter {
    HIGHLIGHTER_FRAGMENTER_UNSPECIFIED = 0;
    // Splits text into fragments of the same size.
    HIGHLIGHTER_FRAGMENTER_SIMPLE = 1;
    // Splits text into fragments of the same size but tries not to split text between highlighted terms.
    HIGHLIGHTER_FRAGMENTER_SPAN = 2;
  }

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  optional HighlighterFragmenter fragmenter = 7;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  optional int32 fragment_size = 8;

  bool highlight_filter = 9;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  optional QueryContainer highlight_query = 10;

  int32 max_fragment_length = 11;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  optional int32 max_analyzed_offset = 12;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  optional int32 no_match_size = 13;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  optional int32 number_of_fragments = 14;

  optional ObjectMap options = 15;

  enum HighlighterOrder {
    HIGHLIGHTER_ORDER_UNSPECIFIED = 0;
    // Sort fragments by relevance.
    HIGHLIGHTER_ORDER_SCORE = 1;
  }

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  optional HighlighterOrder order = 16;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  optional int32 phrase_limit = 17;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 18;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 19;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  optional bool require_field_match = 20;

  enum HighlighterTagsSchema {
    HIGHLIGHTER_TAGS_SCHEMA_UNSPECIFIED = 0;
    // Defines the following pre_tags and defines post_tags as </em>.
    HIGHLIGHTER_TAGS_SCHEMA_STYLED = 1;
  }

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  optional HighlighterTagsSchema tags_schema = 21;

  enum HighlighterEncoder {
    HIGHLIGHTER_ENCODER_UNSPECIFIED = 0;
    // No encoding
    HIGHLIGHTER_ENCODER_DEFAULT = 1;
    // First escape the HTML text and then insert the highlighting tags
    HIGHLIGHTER_ENCODER_HTML = 2;
  }

  // [optional] Specifies whether the highlighted fragment should be HTML encoded before it is returned.
  optional HighlighterEncoder encoder = 22;

  // [required] Specifies the fields to search for text to be highlighted. Supports wildcard expressions. If you use wildcards, only text and keyword fields are highlighted. For example, you can set fields to my_field* to include all text and keyword fields that start with the prefix my_field.
  map<string, HighlightField> fields = 23;

}

message HighlightField {

  enum HighlighterType {
    HIGHLIGHTER_TYPE_UNSPECIFIED = 0;
    // The fvh highlighter uses the Lucene Fast Vector highlighter. This highlighter can be used on fields with term_vector set to with_positions_offsets in the mapping.
    HIGHLIGHTER_TYPE_FVH = 1;
    // The plain highlighter uses the standard Lucene highlighter. It attempts to reflect the query matching logic in terms of understanding word importance and any word positioning criteria in phrase queries.
    HIGHLIGHTER_TYPE_PLAIN = 2;
    // The unified highlighter uses the Lucene Unified Highlighter. This highlighter breaks the text into sentences and uses the BM25 algorithm to score individual sentences as if they were documents in the corpus. It also supports accurate phrase and multi-term (fuzzy, prefix, regex) highlighting. The unified highlighter can combine matches from multiple fields into one result (see matched_fields). This is the default highlighter.
    HIGHLIGHTER_TYPE_UNIFIED = 3;
  }

  // [optional] Specifies the highlighter to use. Default is unified.
  optional HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  optional string boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  optional int32 boundary_max_scan = 3;

  enum BoundaryScanner {
    BOUNDARY_SCANNER_UNSPECIFIED = 0;
    // Split highlighted fragments at any character listed in boundary_chars. Valid only for the fvh highlighter.
    BOUNDARY_SCANNER_CHARS = 1;
    // Split highlighted fragments at sentence boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_SENTENCE = 2;
    // Split highlighted fragments at word boundaries, as defined by the BreakIterator. You can specify the BreakIterator's locale in the boundary_scanner_locale option.
    BOUNDARY_SCANNER_WORD = 3;
  }

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  optional BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  optional string boundary_scanner_locale = 5;

  // [x-deprecated]
  bool force_source = 6;

  enum HighlighterFragmenter {
    HIGHLIGHTER_FRAGMENTER_UNSPECIFIED = 0;
    // Splits text into fragments of the same size.
    HIGHLIGHTER_FRAGMENTER_SIMPLE = 1;
    // Splits text into fragments of the same size but tries not to split text between highlighted terms.
    HIGHLIGHTER_FRAGMENTER_SPAN = 2;
  }

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  optional HighlighterFragmenter fragmenter = 7;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  optional int32 fragment_size = 8;

  bool highlight_filter = 9;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  optional QueryContainer highlight_query = 10;

  int32 max_fragment_length = 11;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  optional int32 max_analyzed_offset = 12;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  optional int32 no_match_size = 13;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  optional int32 number_of_fragments = 14;

  ObjectMap options = 15;

  enum HighlighterOrder {
    HIGHLIGHTER_ORDER_UNSPECIFIED = 0;
    // Sort fragments by relevance.
    HIGHLIGHTER_ORDER_SCORE = 1;
  }

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  optional HighlighterOrder order = 16;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  optional int32 phrase_limit = 17;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 18;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 19;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  optional bool require_field_match = 20;

  enum HighlighterTagsSchema {
    HIGHLIGHTER_TAGS_SCHEMA_UNSPECIFIED = 0;
    // Defines the following pre_tags and defines post_tags as </em>.
    HIGHLIGHTER_TAGS_SCHEMA_STYLED = 1;
  }

  HighlighterTagsSchema tags_schema = 21;

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  optional int32 fragment_offset = 22;

  // [optional] Combines matches from different fields to highlight one field. The most common use case for this functionality is highlighting text that is analyzed in different ways and kept in multi-fields. All fields in the matched_fields list must have the term_vector field set to with_positions_offsets. The field in which the matches are combined is the only loaded field, so it is beneficial to set its store option to yes. Valid only for the fvh highlighter.
  repeated string matched_fields = 23;

  optional Analyzer analyzer = 24;

}

message SortCombinations {
  oneof sort_combinations{
    // [optional] Sort based on field name.
    string string_value = 1;
    // [optional] Sort based on a map of fields with specified order directions.
    FieldWithOrderMap field_with_order_map = 2;
    // [optional] Sort using a combination of advanced sort options, such as score, document ID, geo-distance, or a custom script.
    SortOptions sort_options = 3;
  }
}

message FieldWithOrderMap {
  // [required] Map of fields and their corresponding sort order.
  map<string, ScoreSort> field_with_order_map = 1;
}

message SortOptions {
  oneof sort_options{
    // [optional] Sort by score.
    ScoreSort score = 1 [json_name = "_score"];
    // [optional] Sort by index order.
    ScoreSort doc = 2 [json_name = "_doc"];
    // [optional] Sort by _geo_distance
    GeoDistanceSort geo_distance = 3 [json_name = "_geo_distance"];
    // [optional] Sort based on custom scripts
    ScriptSort script = 4 [json_name = "_script"];
  }
}

message ScoreSort {
  // Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 1;
}

enum SortOrder {
  SORT_ORDER_UNSPECIFIED = 0;
  // Sort in ascending order.
  SORT_ORDER_ASC = 1;
  // Sort in descending order
  SORT_ORDER_DESC = 2;
}

message GeoDistanceSort {

  // Specifies how to handle a field with several geopoints.
  SortMode mode = 1;
  enum SortMode {
    SORT_MODE_UNSPECIFIED = 0;
    // Use the average of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_AVG = 1;
    // Pick the highest value.
    SORT_MODE_MAX = 2;
    // Use the median of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_MEDIAN = 3;
    // Pick the lowest value.
    SORT_MODE_MIN = 4;
    // Use the sum of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_SUM = 5;
  }

  // [optional] Specifies the method of computing the distance.
  GeoDistanceType distance_type = 2;

  enum GeoDistanceType {
    GEO_DISTANCE_TYPE_UNSPECIFIED = 0;
    // Default
    GEO_DISTANCE_TYPE_ARC = 1;
    // Faster but less accurate for long distances or close to the poles.
    GEO_DISTANCE_TYPE_PLANE = 2;
  }

  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  bool ignore_unmapped = 3;

  // [optional] Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 4;

  // [optional] Specifies the units used to compute sort values. Default is meters (m).
  DistanceUnit unit = 5;

  enum DistanceUnit {
    DISTANCE_UNIT_UNSPECIFIED = 0;
    DISTANCE_UNIT_CM = 1;
    DISTANCE_UNIT_FT = 2;
    DISTANCE_UNIT_IN = 3;
    DISTANCE_UNIT_KM = 4;
    DISTANCE_UNIT_M = 5;
    DISTANCE_UNIT_MI = 6;
    DISTANCE_UNIT_MM = 7;
    DISTANCE_UNIT_NMI = 8;
    DISTANCE_UNIT_YD = 9;
  }
}

message ScriptSort {

  // [optional] Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 1;

  // [optional] The script to execute for custom sorting.
  Script script = 2;

  // [optional] Specifies script sort type.
  ScriptSortType type = 3;
  enum ScriptSortType {
    SCRIPT_SORT_TYPE_UNSPECIFIED = 0;
    SCRIPT_SORT_TYPE_NUMBER = 1;
    SCRIPT_SORT_TYPE_STRING = 2;
    SCRIPT_SORT_TYPE_VERSION = 3;
  }

  // [optional] Specifies what array value should be chosen for sorting the document.
  SortMode mode = 4;
  enum SortMode {
    SORT_MODE_UNSPECIFIED = 0;
    // Use the average of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_AVG = 1;
    // Pick the highest value.
    SORT_MODE_MAX = 2;
    // Use the median of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_MEDIAN = 3;
    // Pick the lowest value.
    SORT_MODE_MIN = 4;
    // Use the sum of all values as sort value. Only applicable for number based array fields.
    SORT_MODE_SUM = 5;
  }

  // Supports sorting by fields that are inside one or more nested objects.
  NestedSortValue nested = 5;

}

message NestedSortValue {

  // [optional] A filter that the inner objects inside the nested path should match with in order for its field values to be taken into account by sorting. Common case is to repeat the query / filter inside the nested filter or query. By default no filter is active.
  QueryContainer filter = 1;

  // [optional] The maximum number of children to consider per root document when picking the sort value. Defaults to unlimited.
  int32 max_children = 2;

  // [optional] Same as top-level nested but applies to another nested path within the current nested object.
  NestedSortValue nested = 3;

  // [required] Specifies the path to the field on which to sort.
  string path = 4;

}

message FieldAndFormat {

  // [required] Wildcard pattern. The request returns doc values for field names matching this pattern.
  string field = 1;

  // [optional] Format in which the values are returned.
  string format = 2;

  // [optional] Retrieve unmapped fields in an object from _source
  bool include_unmapped = 3;

}

message FieldCollapse {

  // [required] The document field by which you want to group or collapse the search results
  string field = 1;

  // [optional] Expanding each group uses an additional query for each inner_hit request for every collapsed hit in the response.
  repeated InnerHits inner_hits = 2;

  // [optional] Use to control the maximum number of concurrent searches allowed in this phase.
  optional int32 max_concurrent_group_searches = 3;

  // [optional] Nested collapse within this collapse.
  FieldCollapse collapse = 4;

}

message ScriptScoreQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // Documents with a score lower than this floating point number are excluded from the search results.
  float min_score = 3;

  QueryContainer query = 4;

  Script script = 5;

}

message ExistsQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;
  // [optional]
  // Query name for query tagging.
  string name = 2 [json_name = "_name"];

  // [required]
  // Name of the field you wish to search.
  string field = 3;

}

enum Operator {
  OPERATOR_UNSPECIFIED = 0;
  OPERATOR_AND = 1;
  OPERATOR_OR = 2;
}

message SimpleQueryStringQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // Analyzer used to convert text in the query string into tokens.
  string analyzer = 3;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  bool analyze_wildcard = 4;

  // If `true`, the parser creates a match_phrase query for each multi-position token.
  bool auto_generate_synonyms_phrase_query = 5;

  Operator default_operator = 6;

  repeated string fields = 7;

  PipeSeparatedFlagsSimpleQueryStringFlag flags = 8;

  // Maximum number of terms to which the query expands for fuzzy matching.
  int32 fuzzy_max_expansions = 9;

  // Number of beginning characters left unchanged for fuzzy matching.
  int32 fuzzy_prefix_length = 10;

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool fuzzy_transpositions = 11;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  bool lenient = 12;

  MinimumShouldMatch minimum_should_match = 13;
  // Query string in the simple query string syntax you wish to parse and use for search.
  string query = 14;

  // Suffix appended to quoted text in the query string.
  string quote_field_suffix = 15;

}

message WildcardQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // Allows case insensitive matching of the pattern with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  bool case_insensitive = 3;

  MultiTermQueryRewrite rewrite = 4;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.
  string value = 5;

  // Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.
  string wildcard = 6;

}

message PipeSeparatedFlagsSimpleQueryStringFlag {

  enum SimpleQueryStringFlag {
    SIMPLE_QUERY_STRING_FLAG_UNSPECIFIED = 0;
    SIMPLE_QUERY_STRING_FLAG_ALL = 1;
    SIMPLE_QUERY_STRING_FLAG_AND = 2;
    SIMPLE_QUERY_STRING_FLAG_ESCAPE = 3;
    SIMPLE_QUERY_STRING_FLAG_FUZZY = 4;
    SIMPLE_QUERY_STRING_FLAG_NEAR = 5;
    SIMPLE_QUERY_STRING_FLAG_NONE = 6;
    SIMPLE_QUERY_STRING_FLAG_NOT = 7;
    SIMPLE_QUERY_STRING_FLAG_OR = 8;
    SIMPLE_QUERY_STRING_FLAG_PHRASE = 9;
    SIMPLE_QUERY_STRING_FLAG_PRECEDENCE = 10;
    SIMPLE_QUERY_STRING_FLAG_PREFIX = 11;
    SIMPLE_QUERY_STRING_FLAG_SLOP = 12;
    SIMPLE_QUERY_STRING_FLAG_WHITESPACE = 13;
  }

  oneof pipe_separated_flags_simple_query_string_flag{
    string string_value = 1;
    SimpleQueryStringFlag simple_query_string_flag = 2;
  }

}

message KnnQuery {
  // [required] Specifies the vector field against which to run a search quer
  string field = 1; 
  
  // [optional]
  // Query vector. Must have the same number of dimensions as the vector field you are searching against.
  repeated float vector = 2;

  // [optional]
  // The final number of nearest neighbors to return as top hits.
  optional int32 k = 3;

  // [optional]
  // The minimum similarity score for a neighbor to be considered a hit.
  optional float min_score = 4;

  // [optional]
  // The maximum physical distance in vector space for a neighbor to be considered a hit.
  optional float max_distance = 5;

  // [optional]
  // Filters for the kNN search query. The kNN search will return the top k documents that also match this filter. If filter is not provided, all documents are allowed to match.
  optional QueryContainer filter = 6;

  // [optional]
  // Boost value to apply to kNN scores
  optional float boost = 7;

  // [optional] The name of the query for query tagging.
  optional string underscore_name = 8;

  // [optional]
  // Method parameters are dependent on the combination of engine and method used to create the index.
  // Available method ef_search see https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#ef_search and nprobes "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#nprobes"
  optional ObjectMap method_parameters = 9;

  // [optional]
  // Available in version later than 2.17
  // To explicitly apply rescoring, provide the rescore parameter in a query on a quantized index and specify the oversample_factor "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#rescoring-quantized-results-using-full-precision"
  optional KnnQueryRescore rescore = 10;
  
  // [optional] When true, retrieves scores for all nested field documents within each parent document. Used with nested queries. For more information, see Vector search with nested fields.
  optional bool expand_nested_docs = 11;

}

message RescoreContext {
  optional float oversample_factor = 1;
}

message KnnQueryRescore {
  oneof knn_query_rescore {
    bool enable = 1;

    RescoreContext context = 2;
  }
}

message MatchQueryTypeless {
  oneof match_query_typeless {
    // Standard match query for performing a full-text search, including options for fuzzy matching.
    MatchQuery match_query = 1;
    // Simplified match query syntax by combining the <field> and query parameters
    ObjectMap object_map = 2;
  }
}

message MatchQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  // [optional]
  // Query name for query tagging
  string name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 3;

  // [optional]
  // Specifies whether to create a match phrase query automatically for multi-term synonyms.
  // For example, if you specify ba,batting average as synonyms and search for ba, OpenSearch searches for ba OR "batting average" (if this option is true) or ba OR (batting AND average) (if this option is false).
  // Default is true.
  bool auto_generate_synonyms_phrase_query = 4;

  // [x-deprecated]
  float cutoff_frequency = 5;

  // [optional]
  // The number of character edits (insertions, deletions, substitutions, or transpositions) that it takes to change one word to another when determining whether a term matched a value.
  // For example, the distance between wined and wind is 1. Valid values are non-negative integers or AUTO.
  // The default, AUTO, chooses a value based on the length of each term and is a good choice for most use cases.
  Fuzziness fuzziness = 6;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite fuzzy_rewrite = 7;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [optional]
  // Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option.
  // For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo.
  // The default(true) is a good choice for most use cases.
  bool fuzzy_transpositions = 8;

  // [optional]
  // Setting lenient to true ignores data type mismatches between the query and the document field.
  // For example, a query string of "8.2" could match a field of type float.
  // Default is false.
  bool lenient = 9;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  int32 max_expansions = 10;

  // [optional]
  // If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match.
  // For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  MinimumShouldMatch minimum_should_match = 11;

  // [optional]
  // If the query string contains multiple search terms, whether all terms need to match (AND) or only one term needs to match (OR) for a document to be considered a match.
  // Default is OR.
  Operator operator = 12;

  // [optional]
  // The number of leading characters that are not considered in fuzziness.
  // Default is 0.
  int32 prefix_length = 13;

  message Query {
    oneof query{
      // if the query value is string type.
      string string_value = 1;
      // if the query value is number type.
      GeneralNumber general_number = 2;
      // if the query value is boolean type.
      bool bool_value = 3;
    }
  }

  // [required]
  // The query string to use for search.
  Query query = 14;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string.
  // For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 15;

  enum ZeroTermsQuery {
    ZERO_TERMS_QUERY_UNSPECIFIED = 0;
    // zero_terms_query specifies whether to match all documents (all).
    ZERO_TERMS_QUERY_ALL = 1;
    // zero_terms_query specifies whether to match no documents (none)
    ZERO_TERMS_QUERY_NONE = 2;
  }

}

message BoolQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] The name of the query for query tagging.
  optional string underscore_name = 2 [json_name = "_name"];

  // [optional] The clause (query) must appear in matching documents. However, unlike `must`, the score of the query will be ignored.
  repeated QueryContainer filter = 3;

  // [optional]
  optional MinimumShouldMatch minimum_should_match = 4;

  // [optional]The clause (query) must appear in matching documents and will contribute to the score.
  repeated QueryContainer must = 5;

  // [optional] The clause (query) must not appear in the matching documents. Because scoring is ignored, a score of `0` is returned for all documents.
  repeated QueryContainer must_not = 6;

  // [optional] The clause (query) should appear in the matching document.
  repeated QueryContainer should = 7;
  
  // [optional] Ensures correct behavior when a query contains only `must_not` clauses. By default set to true, OpenSearch adds a match-all clause to ensure results are returned from Lucene, with the `must_not` conditions applied as filters. If set to false, the query may return no results, as Lucene typically requires at least one positive condition.
  optional bool adjust_pure_negative = 8;
}

message MinimumShouldMatch{
  oneof minimum_should_match{
    // if minimum_should_match is integer type. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    int32 int32_value = 1;
    // if minimum_should_match is string type like percentage or combinations. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    string string_value = 2;
  }
}

message BoostingQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.
  float negative_boost = 3;

  QueryContainer negative = 4;

  QueryContainer positive = 5;

}

message ConstantScoreQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  QueryContainer filter = 3;

}

message DisMaxQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // One or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, OpenSearch uses the highest relevance score.
  repeated QueryContainer queries = 3;

  // Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.
  float tie_breaker = 4;

}

message FunctionScoreQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  FunctionBoostMode boost_mode = 3;

  enum FunctionBoostMode {
    FUNCTION_BOOST_MODE_UNSPECIFIED = 0;
    FUNCTION_BOOST_MODE_AVG = 1;
    FUNCTION_BOOST_MODE_MAX = 2;
    FUNCTION_BOOST_MODE_MIN = 3;
    FUNCTION_BOOST_MODE_MULTIPLY = 4;
    FUNCTION_BOOST_MODE_REPLACE = 5;
    FUNCTION_BOOST_MODE_SUM = 6;
  }

  // One or more functions that compute a new score for each document returned by the query.
  repeated FunctionScoreContainer functions = 4;

  // Restricts the new score to not exceed the provided limit.
  float max_boost = 5;

  // Excludes documents that do not meet the provided score threshold.
  float min_score = 6;

  QueryContainer query = 7;

  FunctionScoreMode score_mode = 8;

  enum FunctionScoreMode {
    FUNCTION_SCORE_MODE_UNSPECIFIED = 0;
    FUNCTION_SCORE_MODE_AVG = 1;
    FUNCTION_SCORE_MODE_FIRST = 2;
    FUNCTION_SCORE_MODE_MAX = 3;
    FUNCTION_SCORE_MODE_MIN = 4;
    FUNCTION_SCORE_MODE_MULTIPLY = 5;
    FUNCTION_SCORE_MODE_SUM = 6;
  }

}

message IntervalsAllOf {

  // An array of rules to combine. All rules must produce a match in a document for the overall source to match.
  repeated IntervalsContainer intervals = 1;

  // Maximum number of positions between the matching terms. Intervals produced by the rules further apart than this are not considered matches.
  int32 max_gaps = 2;

  // If `true`, intervals produced by the rules should appear in the order in which they are specified.
  bool ordered = 3;

  IntervalsFilter filter = 4;

}

message IntervalsAnyOf {

  // An array of rules to match.
  repeated IntervalsContainer intervals = 1;

  IntervalsFilter filter = 2;

}

message IntervalsMatch {

  // Analyzer used to analyze terms in the query.
  string analyzer = 1;

  // Maximum number of positions between the matching terms. Terms further apart than this are not considered matches.
  int32 max_gaps = 2;

  // If `true`, matching terms must appear in their specified order.
  bool ordered = 3;

  // Text you wish to find in the provided field.
  string query = 4;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 5;

  IntervalsFilter filter = 6;

}

message IntervalsQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  oneof intervals_query {
    IntervalsAllOf all_of = 3;

    IntervalsAnyOf any_of = 4;

    IntervalsFuzzy fuzzy = 5;

    IntervalsMatch match = 6;

    IntervalsPrefix prefix = 7;

    IntervalsWildcard wildcard = 8;
  }

}

message FunctionScoreContainer {
  QueryContainer filter = 1;

  float weight = 2;

  //TODO: add decay function
  oneof function_score_container {

    //   Decay function not supported
    //    DecayFunction exp = 3;
    //
    //    DecayFunction gauss = 4;
    //
    //    DecayFunction linear = 5;

    FieldValueFactorScoreFunction field_value_factor = 6;

    RandomScoreFunction random_score = 7;

    ScriptScoreFunction script_score = 8;
  }

}

message ScriptScoreFunction {

  Script script = 1;

}

message IntervalsFilter {
  oneof intervals_filter {
    IntervalsContainer after = 1;

    IntervalsContainer before = 2;

    IntervalsContainer contained_by = 3;

    IntervalsContainer containing = 4;

    IntervalsContainer not_contained_by = 5;

    IntervalsContainer not_containing = 6;

    IntervalsContainer not_overlapping = 7;

    IntervalsContainer overlapping = 8;

    Script script = 9;
  }

}

message IntervalsContainer {

  oneof intervals_container {
    IntervalsAllOf all_of = 1;

    IntervalsAnyOf any_of = 2;

    IntervalsFuzzy fuzzy = 3;

    IntervalsMatch match = 4;

    IntervalsPrefix prefix = 5;

    IntervalsWildcard wildcard = 6;
  }

}

message PrefixQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  // [optional]
  // Query name for query tagging
  string name = 2 [json_name = "_name"];

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite rewrite = 3;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [required]
  // The term to search for in the field specified in <field>.
  string value = 4;

  // [optional]
  // Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  bool case_insensitive = 5;

}

message TermsLookupFieldStringArrayMap {
  oneof terms_lookup_field_string_array_map {
    // terms_lookup_field terms you wish to find in the provided field
    TermsLookupField terms_lookup_field = 1;
    // string_array terms value you wish to find in the provided field
    StringArray string_array = 2;
  }
}

enum ValueType {
    VALUE_TYPE_UNSPECIFIED = 0;
    VALUE_TYPE_BITMAP = 1;
    VALUE_TYPE_DEFAULT = 2;
}

message TermsQueryField {
  // [optional]
  // A floating-point value that specifies the weight of this field toward the relevance score. Values above 1.0 increase the field's relevance. Values between 0.0 and 1.0 decrease the field's relevance.
  // Default is 1.0.
  optional float boost = 1;
  
  // [optional]
  // Query name for query tagging
  optional string name = 2; 
  
  // [optional] Specifies the types of values used for filtering. Valid values are default and bitmap. If omitted, the value defaults to default.
  optional ValueType value_type = 3; 
  
  // [required]
  map<string, TermsLookupFieldStringArrayMap> terms_lookup_field_string_array_map = 4;
}

message TermsLookupField {

  // [required]
  // The name of the index from which to fetch field values
  string index = 1;

  // [required]
  // The document ID of the document from which to fetch field values.
  string id = 2;

  // [required]
  // The name of the field from which to fetch field values. Specify nested fields using dot path notation
  string path = 3;

  // [optional]
  // Custom routing value of the document from which to fetch term values. If a custom routing value was provided when the document was indexed, this parameter is required.
  optional string routing = 4;
  
  // [optional] 
  optional bool store = 5;
  
}

message TermsSetQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  // [optional]
  // Query name for query tagging
  string name = 2 [json_name = "_name"];

  // [optional]
  // The name of the numeric field that specifies the number of matching terms required in order to return a document in the results.
  string minimum_should_match_field = 3;

  // [optional]
  // A script that returns the number of matching terms required in order to return a document in the results.
  Script minimum_should_match_script = 4;

  // [required]
  // The array of terms to search for in the field specified in <field>. A document is returned in the results only if the required number of terms matches the document's field values exactly, with the correct spacing and capitalization.
  repeated string terms = 5;

}

message TermQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional]
  // Query name for query tagging
  optional string name = 2 [json_name = "_name"];

  // [required]
  // Term you wish to find in the provided <field>. To return a document, the term must exactly match the field value, including whitespace and capitalization.
  FieldValue value = 3;

  // [optional]
  // Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. When `false`, the case sensitivity of matching depends on the underlying field's mapping.
  optional bool case_insensitive = 4;

}


message QueryStringQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  bool allow_leading_wildcard = 3;

  // Analyzer used to convert text in the query string into tokens.
  string analyzer = 4;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  bool analyze_wildcard = 5;

  // If `true`, match phrase queries are automatically created for multi-term synonyms.
  bool auto_generate_synonyms_phrase_query = 6;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string default_field = 7;

  Operator default_operator = 8;

  // If `true`, enable position increments in queries constructed from a `query_string` search.
  bool enable_position_increments = 9;

  bool escape = 10;

  repeated string fields = 11;

  Fuzziness fuzziness = 12;

  // Maximum number of terms to which the query expands for fuzzy matching.
  int32 fuzzy_max_expansions = 13;

  // Number of beginning characters left unchanged for fuzzy matching.
  int32 fuzzy_prefix_length = 14;

  MultiTermQueryRewrite fuzzy_rewrite = 15;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool fuzzy_transpositions = 16;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  bool lenient = 17;

  // Maximum number of automaton states required for the query.
  int32 max_determinized_states = 18;

  MinimumShouldMatch minimum_should_match = 19;

  // Maximum number of positions allowed between matching tokens for phrases.
  int32 phrase_slop = 20;

  // Query string you wish to parse and use for search.
  string query = 21;

  // Analyzer used to convert quoted text in the query string into tokens. For quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.
  string quote_analyzer = 22;

  // Suffix appended to quoted text in the query string. You can use this suffix to use a different analysis method for exact matches.
  string quote_field_suffix = 23;

  MultiTermQueryRewrite rewrite = 24;

  // How to combine the queries generated from the individual search terms in the resulting `dis_max` query.
  float tie_breaker = 25;

  string time_zone = 26;

  TextQueryType type = 27;
  enum TextQueryType {
    TEXT_QUERY_TYPE_UNSPECIFIED = 0;
    TEXT_QUERY_TYPE_BEST_FIELDS = 1;
    TEXT_QUERY_TYPE_BOOL_PREFIX = 2;
    TEXT_QUERY_TYPE_CROSS_FIELDS = 3;
    TEXT_QUERY_TYPE_MOST_FIELDS = 4;
    TEXT_QUERY_TYPE_PHRASE = 5;
    TEXT_QUERY_TYPE_PHRASE_PREFIX = 6;
  }

}

message RandomScoreFunction {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  message Seed {
    oneof seed {
      int32 int32_value = 1;
      string string_value = 2;
    }
  }
  Seed seed = 2;
}

// TODO: need to revisit RangeQuery def
message RangeQuery {
  oneof range_query{
    DateRangeQuery date_range_query = 1;
    NumberRangeQuery number_range_query = 2;
  }
}

message RegexpQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`. When `false`, case sensitivity of matching depends on the underlying field's mapping.
  bool case_insensitive = 3;

  // Enables optional operators for the regular expression.
  string flags = 4;

  // Maximum number of automaton states required for the query.
  int32 max_determinized_states = 5;

  MultiTermQueryRewrite rewrite = 6;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // Regular expression for terms you wish to find in the provided field.
  string value = 7;

}

message DateRangeQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  RangeRelation relation = 3;
  enum RangeRelation {
    RANGE_RELATION_UNSPECIFIED = 0;
    RANGE_RELATION_CONTAINS = 1;
    RANGE_RELATION_INTERSECTS = 2;
    RANGE_RELATION_WITHIN = 3;
  }

  string gt = 4;

  string gte = 5;

  string lt = 6;

  string lte = 7;

  message From {
    oneof from {
      string string_value = 1;
      NullValue null_value = 2;
    }
  }

  From from = 8;

  message To {
    oneof to {
      string string_value = 1;
      NullValue null_value = 2;
    }
  }
  To to = 9;

  string format = 10;

  string time_zone = 11;

}

message NumberRangeQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  RangeRelation relation = 3;
  enum RangeRelation {
    RANGE_RELATION_UNSPECIFIED = 0;
    RANGE_RELATION_CONTAINS = 1;
    RANGE_RELATION_INTERSECTS = 2;
    RANGE_RELATION_WITHIN = 3;
  }


  // Greater than.
  GeneralNumber gt = 4;

  // Greater than or equal to.
  GeneralNumber gte = 5;

  // Less than.
  GeneralNumber lt = 6;

  // Less than or equal to.
  GeneralNumber lte = 7;

  message From {
    oneof from {
      string string_value = 1;
      GeneralNumber general_number = 2;
      NullValue null_value = 3;
    }
  }
  From from = 8;

  message To {
    oneof to {
      string string_value = 1;
      GeneralNumber general_number = 2;
      NullValue null_value = 3;
    }
  }
  To to = 9;
}

message FuzzyQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  // [optional]
  // Query name for query tagging
  string name = 2 [json_name = "_name"];

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  int32 max_expansions = 3;

  // [optional]
  // The number of leading characters that are not considered in fuzziness. Default is 0.
  int32 prefix_length = 4;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite rewrite = 5;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }
  // [optional]
  // Specifies whether to allow transpositions of two adjacent characters (ab to ba) as edits. Default is true.
  bool transpositions = 6;
  // [optional]
  // The number of character edits (insert, delete, substitute) needed to change one word to another when determining whether a term matched a value.
  Fuzziness fuzziness = 7;

  message Value {
    oneof value {
      string string_value = 1;
      bool bool_value = 2;
      GeneralNumber general_number = 3;
    }
  }

  // [required]
  // Term you wish to find in the provided <field>.
  Value value = 8;
}

message Fuzziness{

  oneof fuzziness{
    // AUTO: Generates an edit distance based on the length of the term. Low and high distance arguments may be optionally provided AUTO:[low],[high]. AUTO should generally be the preferred value for fuzziness.
    string string_value = 1;
    // 0,1,2: The maximum allowed Levenshtein Edit Distance (or number of edits)
    int32 int32_value = 2;
  }

}

message FieldValue {
  oneof type{
    GeneralNumber general_number = 1;
    string string_value = 2;
    ObjectMap object_map = 3;
    bool bool_value = 4;
  }
}

message IdsQuery {

  float boost = 1;

  string name = 2 [json_name = "_name"];

  repeated string values = 3;

}

message IntervalsFuzzy {

  // Analyzer used to normalize the term.
  string analyzer = 1;

  Fuzziness fuzziness = 2;

  // Number of beginning characters left unchanged when creating expansions.
  int32 prefix_length = 3;

  // The term to match.
  string term = 4;

  // Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool transpositions = 5;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 6;

}

message IntervalsPrefix {

  // Analyzer used to analyze the `prefix`.
  string analyzer = 1;

  // Beginning characters of terms you wish to find in the top-level field.
  string prefix = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 3;

}

message IntervalsWildcard {

  // Analyzer used to analyze the `pattern`. Defaults to the top-level field's analyzer.
  string analyzer = 1;

  // Wildcard pattern used to find matching terms.
  string pattern = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 3;

}

message MatchAllQuery {

  // [optional]
  // Boosts the clause by the given multiplier. Useful for weighing clauses in compound queries. Values in the [0, 1) range decrease relevance, and values greater than 1 increase relevance. Default is 1.
  optional float boost = 1;

  // [optional]
  // Query name for query tagging
  optional string name = 2 [json_name = "_name"];
}

message MatchBoolPrefixQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  // [optional]
  // Query name for query tagging
  string name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 3;

  // [optional]
  // The number of character edits (insert, delete, substitute) that it takes to change one word to another when determining whether a term matched a value.
  // For example, the distance between wined and wind is 1.
  // The default, AUTO, chooses a value based on the length of each term and is a good choice for most use cases.
  Fuzziness fuzziness = 4;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite fuzzy_rewrite = 5;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [optional]
  // Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option.
  // For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo.
  // The default(true) is a good choice for most use cases.
  bool fuzzy_transpositions = 6;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  int32 max_expansions = 7;

  // [optional]
  // If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match.
  // For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  MinimumShouldMatch minimum_should_match = 8;

  // [optional]
  // If the query string contains multiple search terms, whether all terms need to match (and) or only one term needs to match (or) for a document to be considered a match.
  // Default is or.
  Operator operator = 9;
  
  // [optional]
  // The number of leading characters that are not considered in fuzziness.
  // Default is 0.
  int32 prefix_length = 10;

  // [required]
  // Terms you wish to find in the provided field. The last term is used in a prefix query.
  string query = 11;

}

message MatchNoneQuery {
  optional float boost = 1;

  optional string name = 2 [json_name = "_name"];
}


enum ZeroTermsQuery {
  ZERO_TERMS_QUERY_UNSPECIFIED = 0;
  // zero_terms_query specifies whether to match all documents (all).
  ZERO_TERMS_QUERY_ALL = 1;
  // zero_terms_query specifies whether to match no documents (none)
  ZERO_TERMS_QUERY_NONE = 2;
}

message MatchPhrasePrefixQuery {
  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  // [optional]
  // Query name for query tagging
  string name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 3;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  int32 max_expansions = 4;

  // [required]
  // The query string to use for search
  string query = 5;

  // [optional]
  // Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase.
  // For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  int32 slop = 6;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 7;

}

message MatchPhraseQuery {

  // [optional]
  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  // [optional]
  // Query name for query tagging
  string name = 2 [json_name = "_name"];

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 3;

  // [required]
  // The query string to use for search.
  string query = 4;

  // [optional]
  // Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase. For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  int32 slop = 5;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 6;

}

message MultiMatchQuery {

  // Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  float boost = 1;

  string name = 2 [json_name = "_name"];

  // Analyzer used to convert the text in the query value into tokens.
  string analyzer = 3;

  // If `true`, match phrase queries are automatically created for multi-term synonyms.
  bool auto_generate_synonyms_phrase_query = 4;

  float cutoff_frequency = 5;

  repeated string fields = 6;

  Fuzziness fuzziness = 7;

  string fuzzy_rewrite = 8;

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`). Can be applied to the term subqueries constructed for all terms but the final term.
  MultiTermQueryRewrite fuzzy_transpositions = 9;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.
  bool lenient = 10;

  // Maximum number of terms to which the query will expand.
  int32 max_expansions = 11;

  MinimumShouldMatch minimum_should_match = 12;

  Operator operator = 13;
  
  // Number of beginning characters left unchanged for fuzzy matching.
  int32 prefix_length = 14;

  // Text, number, boolean value or date you wish to find in the provided field.
  string query = 15;

  // Maximum number of positions allowed between matching tokens.
  int32 slop = 16;

  // Determines how scores for each per-term blended query and scores across groups are combined.
  float tie_breaker = 17;

  TextQueryType type = 18;
  enum TextQueryType {
    TEXT_QUERY_TYPE_UNSPECIFIED = 0;
    TEXT_QUERY_TYPE_BEST_FIELDS = 1;
    TEXT_QUERY_TYPE_BOOL_PREFIX = 2;
    TEXT_QUERY_TYPE_CROSS_FIELDS = 3;
    TEXT_QUERY_TYPE_MOST_FIELDS = 4;
    TEXT_QUERY_TYPE_PHRASE = 5;
    TEXT_QUERY_TYPE_PHRASE_PREFIX = 6;
  }

  ZeroTermsQuery zero_terms_query = 19;
  enum ZeroTermsQuery {
    ZERO_TERMS_QUERY_UNSPECIFIED = 0;
    ZERO_TERMS_QUERY_ALL = 1;
    ZERO_TERMS_QUERY_NONE = 2;
  }

}

message FieldValueFactorScoreFunction {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  // Optional factor to multiply the field value with.
  float factor = 2;

  // Value used if the document doesn't have that field. The modifier and factor are still applied to it as though it were read from the document.
  double missing = 3;

  FieldValueFactorModifier modifier = 4;

  enum FieldValueFactorModifier {
    FIELD_VALUE_FACTOR_MODIFIER_UNSPECIFIED = 0;
    FIELD_VALUE_FACTOR_MODIFIER_LN = 1;
    FIELD_VALUE_FACTOR_MODIFIER_LN1P = 2;
    FIELD_VALUE_FACTOR_MODIFIER_LN2P = 3;
    FIELD_VALUE_FACTOR_MODIFIER_LOG = 4;
    FIELD_VALUE_FACTOR_MODIFIER_LOG1P = 5;
    FIELD_VALUE_FACTOR_MODIFIER_LOG2P = 6;
    FIELD_VALUE_FACTOR_MODIFIER_NONE = 7;
    FIELD_VALUE_FACTOR_MODIFIER_RECIPROCAL = 8;
    FIELD_VALUE_FACTOR_MODIFIER_SQRT = 9;
    FIELD_VALUE_FACTOR_MODIFIER_SQUARE = 10;
  }

}

message DutchAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_DUTCH = 1;
  }
  Type type = 1;

  repeated string stopwords = 2;
}

message FingerprintAnalyzer {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_FINGERPRINT = 1;
  }
  Type type = 1;

  string version = 2;

  float max_output_size = 3;

  bool preserve_original = 4;

  string separator = 5;

  // Language value, such as _arabic_ or _thai_. Defaults to _english_. Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words. Also accepts an array of stop words.
  repeated string stopwords = 6;

  string stopwords_path = 7;
}

message IcuAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_ICU_ANALYZER = 1;
  }
  Type type = 1;

  enum IcuNormalizationType {
    ICU_NORMALIZATION_TYPE_UNSPECIFIED = 0;
    ICU_NORMALIZATION_TYPE_NFC = 1;
    ICU_NORMALIZATION_TYPE_NFKC = 2;
    ICU_NORMALIZATION_TYPE_NFKC_CF = 3;
  }
  IcuNormalizationType method = 2;

  enum IcuNormalizationMode {
    ICU_NORMALIZATION_MODE_UNSPECIFIED = 0;
    ICU_NORMALIZATION_MODE_COMPOSE = 1;
    ICU_NORMALIZATION_MODE_DECOMPOSE = 2;
  }

  IcuNormalizationMode mode = 3;
}

//manual generate
message KeywordAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_KEYWORD = 1;
  }
  Type type = 1;

  string version = 2;
}

message KuromojiAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_KUROMOJI = 1;
  }
  Type type = 1;


  enum Mode {
    MODE_UNSPECIFIED = 0;
    MODE_EXTENDED = 1;
    MODE_NORMAL = 2;
    MODE_SEARCH = 3;
  }

  Mode mode = 2;

  string user_dictionary = 3;
}


message LanguageAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_LANGUAGE = 1;
  }
  Type type = 1;

  string version = 2;

  enum Language {
    LANGUAGE_UNSPECIFIED = 0;
    LANGUAGE_ARABIC = 1;
    LANGUAGE_ARMENIAN = 2;
    LANGUAGE_BASQUE = 3;
    LANGUAGE_BRAZILIAN = 4;
    LANGUAGE_BULGARIAN = 5;
    LANGUAGE_CATALAN = 6;
    LANGUAGE_CHINESE = 7;
    LANGUAGE_CJK = 8;
    LANGUAGE_CZECH = 9;
    LANGUAGE_DANISH = 10;
    LANGUAGE_DUTCH = 11;
    LANGUAGE_ENGLISH = 12;
    LANGUAGE_ESTONIAN = 13;
    LANGUAGE_FINNISH = 14;
    LANGUAGE_FRENCH = 15;
    LANGUAGE_GALICIAN = 16;
    LANGUAGE_GERMAN = 17;
    LANGUAGE_GREEK = 18;
    LANGUAGE_HINDI = 19;
    LANGUAGE_HUNGARIAN = 20;
    LANGUAGE_INDONESIAN = 21;
    LANGUAGE_IRISH = 22;
    LANGUAGE_ITALIAN = 23;
    LANGUAGE_LATVIAN = 24;
    LANGUAGE_NORWEGIAN = 25;
    LANGUAGE_PERSIAN = 26;
    LANGUAGE_PORTUGUESE = 27;
    LANGUAGE_ROMANIAN = 28;
    LANGUAGE_RUSSIAN = 29;
    LANGUAGE_SORANI = 30;
    LANGUAGE_SPANISH = 31;
    LANGUAGE_SWEDISH = 32;
    LANGUAGE_THAI = 33;
    LANGUAGE_TURKISH = 34;
  }

  Language language = 3;

  repeated string stem_exclusion = 4;

  // Language value, such as _arabic_ or _thai_. Defaults to _english_. Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words. Also accepts an array of stop words.
  repeated string stopwords = 5;

  string stopwords_path = 6;

}

message NoriAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_NORI = 1;
  }
  Type type = 1;

  string version = 2;

  enum NoriDecompoundMode {
    NORI_DECOMPOUND_MODE_UNSPECIFIED = 0;
    NORI_DECOMPOUND_MODE_NONE = 1;
    NORI_DECOMPOUND_MODE_DISCARD = 2;
    NORI_DECOMPOUND_MODE_MIXED = 3;
  }

  NoriDecompoundMode decompound_mode = 3;

  repeated string stoptags = 4;

  string user_dictionary = 5;
}

message PatternAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_PATTERN = 1;
  }
  Type type = 1;

  string version = 2;

  string flags = 3;

  bool lowercase = 4;

  string pattern = 5;

  repeated string stopwords = 6;

}

message SimpleAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_SIMPLE = 1;
  }
  Type type = 1;

  string version = 2;
}

message SnowballAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_SNOWBALL = 1;
  }
  Type type = 1;

  string version = 2;

  enum SnowballLanguage {
    SNOWBALL_LANGUAGE_UNSPECIFIED = 0;
    SNOWBALL_LANGUAGE_ARMENIAN = 1;
    SNOWBALL_LANGUAGE_BASQUE = 2;
    SNOWBALL_LANGUAGE_CATALAN = 3;
    SNOWBALL_LANGUAGE_DANISH = 4;
    SNOWBALL_LANGUAGE_DUTCH = 5;
    SNOWBALL_LANGUAGE_ENGLISH = 6;
    SNOWBALL_LANGUAGE_FINNISH = 7;
    SNOWBALL_LANGUAGE_FRENCH = 8;
    SNOWBALL_LANGUAGE_GERMAN = 9;
    SNOWBALL_LANGUAGE_GERMAN2 = 10;
    SNOWBALL_LANGUAGE_HUNGARIAN = 11;
    SNOWBALL_LANGUAGE_ITALIAN = 12;
    SNOWBALL_LANGUAGE_KP = 13;
    SNOWBALL_LANGUAGE_LOVINS = 14;
    SNOWBALL_LANGUAGE_NORWEGIAN = 15;
    SNOWBALL_LANGUAGE_PORTER = 16;
    SNOWBALL_LANGUAGE_PORTUGUESE = 17;
    SNOWBALL_LANGUAGE_ROMANIAN = 18;
    SNOWBALL_LANGUAGE_RUSSIAN = 19;
    SNOWBALL_LANGUAGE_SPANISH = 20;
    SNOWBALL_LANGUAGE_SWEDISH = 21;
    SNOWBALL_LANGUAGE_TURKISH = 22;
  }

  SnowballLanguage language = 3;

  repeated string stopwords = 4;
}

message StandardAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_STANDARD = 1;
  }
  Type type = 1;

  float max_token_length = 2;
  repeated string stopwords = 3;
}

message StopAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_STOP = 1;
  }
  Type type = 1;

  string version = 2;

  repeated string stopwords = 3;

  string stopwords_path = 4;
}

message WhitespaceAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_WHITESPACE = 1;
  }
  Type type = 1;

  string version = 2;

}

message CustomAnalyzer {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_CUSTOM = 1;
  }

  Type type = 1;

  repeated string char_filter = 2;

  repeated string filter = 3;

  float position_increment_gap = 4;

  float position_offset_gap = 5;

  string tokenizer = 6;
}

message Analyzer {
  oneof analyzer {
    CustomAnalyzer custom_analyzer = 1;
    FingerprintAnalyzer fingerprint_analyzer = 2;
    KeywordAnalyzer keyword_analyzer = 3;
    LanguageAnalyzer language_analyzer = 4;
    NoriAnalyzer nori_analyzer = 5;
    PatternAnalyzer pattern_analyzer = 6;
    SimpleAnalyzer simple_analyzer = 7;
    StandardAnalyzer standard_analyzer = 8;
    StopAnalyzer stop_analyzer = 9;
    WhitespaceAnalyzer whitespace_analyzer = 10;
    IcuAnalyzer icu_analyzer = 11;
    KuromojiAnalyzer kuromoji_analyzer = 12;
    SnowballAnalyzer snowball_analyzer = 13;
    DutchAnalyzer dutch_analyzer = 14;
  }
}

message Error {
  oneof version {
    OpenSearchExceptionV1 v1 = 1;
  }
}


message OpenSearchExceptionV1 {
  string type = 1;
  string reason = 2;
  repeated .google.protobuf.Struct root_cause = 3;

  .google.protobuf.Struct caused_by = 4;
  string stack_trace = 5;
  .google.protobuf.Struct suppressed = 6;

  .google.protobuf.Struct additional_details = 7;
}

message InlineGet {

  .google.protobuf.Struct fields = 1;

  bool found = 2;

  int64 seq_no = 3 [json_name = "_seq_no"];

  int64 primary_term = 4 [json_name = "_primary_term"];

  repeated string routing = 5 [json_name = "_routing"];

  oneof inline_get_source {

    // struct_source field to be returned upon explicit request by user
    .google.protobuf.Struct struct_source = 6;

    // Use bytes for better latency/performance, as it reduces payload size over the wire
    bytes source = 7 [json_name = "_source"];

  }
}
