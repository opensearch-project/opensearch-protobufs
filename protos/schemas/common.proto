/**
This is generated from the spec. DO NOT manually modify.
*/
syntax = "proto3";
package org.opensearch.protobufs;

option java_multiple_files = true;
option java_package = "org.opensearch.protobufs";
option java_outer_classname = "CommonProto";
option go_package = "github.com/opensearch-project/opensearch-protobufs/go/opensearchpb";

import "google/protobuf/struct.proto";

// TODO: not supported yet in server
message GlobalParams {
  // [optional] Whether to return human-readable values for statistics.
  optional bool human = 1;
  // [optional] Whether to include the stack trace of returned errors.
  optional bool error_trace = 2;
  // [optional] A comma-separated list of filters used to filter the response. Use wildcards to match any field or part of a field's name. To exclude fields, use `-`.
  repeated string filter_path = 3;
}

message WaitForActiveShards {

  oneof wait_for_active_shards {
    int32 int32 = 1;
    WaitForActiveShardOptions wait_for_active_shard_options = 2;
  }
}
enum WaitForActiveShardOptions {
  WAIT_FOR_ACTIVE_SHARD_OPTIONS_UNSPECIFIED = 0;
  WAIT_FOR_ACTIVE_SHARD_OPTIONS_ALL = 1;
  WAIT_FOR_ACTIVE_SHARD_OPTIONS_NULL = 2;
}

message Script {
  oneof script {
    // Defines an inline script to execute as part of a query.
    InlineScript inline = 1;
    // References a stored script by its ID for use in a query.
    StoredScriptId stored = 2;
  }
}

message InlineScript {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;

  // [optional]
  // The script's language. Default is painless.
  ScriptLanguage lang = 2;

  map<string, string> options = 3;

  // [required]
  // The script source.
  string source = 4;
}

message ScriptLanguage {
  oneof script_language {
    BuiltinScriptLanguage builtin = 1;

    string custom = 2;
  }
}

enum BuiltinScriptLanguage {
  BUILTIN_SCRIPT_LANGUAGE_UNSPECIFIED = 0;
  BUILTIN_SCRIPT_LANGUAGE_EXPRESSION = 1;
  BUILTIN_SCRIPT_LANGUAGE_JAVA = 2;
  BUILTIN_SCRIPT_LANGUAGE_MUSTACHE = 3;
  BUILTIN_SCRIPT_LANGUAGE_PAINLESS = 4;
}

enum ExpandWildcard {
  EXPAND_WILDCARD_UNSPECIFIED = 0;
  EXPAND_WILDCARD_ALL = 1;
  EXPAND_WILDCARD_CLOSED = 2;
  EXPAND_WILDCARD_HIDDEN = 3;
  EXPAND_WILDCARD_NONE = 4;
  EXPAND_WILDCARD_OPEN = 5;
}

enum SearchType {
  SEARCH_TYPE_UNSPECIFIED = 0;
  SEARCH_TYPE_DFS_QUERY_THEN_FETCH = 1;
  SEARCH_TYPE_QUERY_THEN_FETCH = 2;
}

enum SuggestMode {
  SUGGEST_MODE_UNSPECIFIED = 0;
  // Use suggestions based on the provided terms
  SUGGEST_MODE_ALWAYS = 1;
  // Use suggestions for terms not in the index
  SUGGEST_MODE_MISSING = 2;
  // Use suggestions that have more occurrences
  SUGGEST_MODE_POPULAR = 3;
}

message StoredScriptId {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;
  // [required]
  // The ID of a stored script previously created using the Create Stored Script API.
  string id = 2;
}

message ObjectMap {
  map<string, Value> fields = 1;

  message Value {
    oneof value {
      NullValue null_value = 1;
      int32 int32 = 2;
      int64 int64 = 3;
      float float = 4;
      double double = 5;
      string string = 6;
      bool bool = 7;
      ObjectMap object_map = 8;
      ListValue list_value = 9;
    }
  }

  // `ListValue` is a wrapper around a repeated field of values.
  // The JSON representation for `ListValue` is JSON array.
  message ListValue {
    // Repeated field of dynamically typed values.
    repeated Value value = 1;
  }
}

enum NullValue {
  NULL_VALUE_UNSPECIFIED = 0;
  NULL_VALUE_NULL = 1;
}

// [optional] Controls how document source fields are returned in the response.
// - If not set, source is returned as bytes (default, recommended for better performance)
// - If set to SOURCE_TYPE_STRUCT: source is returned as a structured protobuf message
enum SourceType {
  SOURCE_TYPE_UNSPECIFIED = 0;
  SOURCE_TYPE_STRUCT = 1;
}

message GeoLocation {
  oneof geo_location {
    // The location specified using latitude and longitude coordinates.
    LatLonGeoLocation latlon = 1;

    // The location specified using a geohash value.
    GeoHashLocation geohash = 2;

    DoubleArray double_array = 3;

    // The location specified as a string in `lat,lon` or WKT format.
    string text = 4;
  }
}

message DoubleArray {
  // The location specified as an array of `[longitude, latitude]`.
  repeated double double_array = 1;
}

message NumberArray {

  repeated double number_array = 1;

}

message LatLonGeoLocation {
  // [required] Latitude
  double lat = 1;

  // [required] Longitude
  double lon = 2;

}

message GeoHashLocation {
  // [required]
  string geohash = 1;

}

message GeneralNumber {
  oneof value{
    int32 int32_value = 1;
    int64 int64_value = 2;
    float float_value = 3;
    double double_value = 4;
  }
}

message SourceConfigParam {

  oneof source_config_param {
    // `true` or `false` to return the `_source` field or not
    bool bool = 1;
    // list of fields to be retrieved from `_source`
    StringArray string_array = 2;
  }

}

message StringArray{
  repeated string string_array = 1;
}

message StringOrStringArray {
  oneof string_or_string_array{
    string string = 1;
    StringArray string_array = 2;
  }
}


message Id {
  oneof id {
    NullValue null_value = 1;
    string string = 2;
  }
}


message SourceConfig {

  oneof source_config{
    // [optional] if the source_config is bool value. true: The entire document source is returned. false: The document source is not returned.
    bool fetch = 1;

    // [optional] source_filter type containing a list of source fields to include or exclude.
    SourceFilter filter = 2;
  }

}

message RuntimeField {

  // For type `lookup`
  repeated RuntimeFieldFetchFields fetch_fields = 1;

  // A custom format for `date` type runtime fields.
  string format = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string input_field = 3;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string target_field = 4;

  string target_index = 5;

  Script script = 6;

  RuntimeFieldType type = 7;

}

enum RuntimeFieldType {
  RUNTIME_FIELD_TYPE_UNSPECIFIED = 0;
  RUNTIME_FIELD_TYPE_BOOLEAN = 1;
  RUNTIME_FIELD_TYPE_DATE = 2;
  RUNTIME_FIELD_TYPE_DOUBLE = 3;
  RUNTIME_FIELD_TYPE_GEO_POINT = 4;
  RUNTIME_FIELD_TYPE_IP = 5;
  RUNTIME_FIELD_TYPE_KEYWORD = 6;
  RUNTIME_FIELD_TYPE_LONG = 7;
  RUNTIME_FIELD_TYPE_LOOKUP = 8;
}

message RuntimeFieldFetchFields {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  string format = 2;

}

message SourceFilter {
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to exclude from the response.
  repeated string excludes = 1;
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to return.
  repeated string includes = 2;
}

message ErrorCause {

  // [required] The type of error
  string type = 1;

  // A human-readable explanation of the error, in english
  optional string reason = 2;

  // The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.
  optional string stack_trace = 3;

  optional ErrorCause caused_by = 4;

  repeated ErrorCause root_cause = 5;

  repeated ErrorCause suppressed = 6;

  optional string index = 7;

  optional string shard = 8;

  optional string index_uuid = 9;

  // [optional] The spec actually does not have a field named 'metadata'. This should have adaptor_unnest.
  map<string, ObjectMap.Value> metadata = 10;

  // [optional]
  map<string, StringOrStringArray> header = 11;
}
message ShardStatistics {
  // [required] Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having failed+successful less than total is thus an indication that some of the shards were not allocated.
  int32 failed = 1;

  // [required] Number of shards that executed the request successfully.
  int32 successful = 2;

  // [required] Total number of shards that require querying, including unallocated shards.
  int32 total = 3;

  // [optional] An array of any shard-specific failures that occurred during the search operation.
  repeated ShardFailure failures = 4;

  // [optional] Number of shards that skipped the request because a lightweight check helped realize that no documents could possibly match on this shard. This typically happens when a search request includes a range filter and the shard only has values that fall outside of that range.
  int32 skipped = 5;

}

message ShardInfo {
  // [required] Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having failed+successful less than total is thus an indication that some of the shards were not allocated.
  int32 failed = 1;

  // [required] Number of shards that executed the request successfully.
  int32 successful = 2;

  // [required] Total number of shards that require querying, including unallocated shards.
  int32 total = 3;

  // [optional] An array of any shard-specific failures that occurred during the search operation.
  repeated ShardFailure failures = 4;

}

message ShardFailure {

  // [optional] Name of the index in which the shard failure occurred.
  optional string index = 1;

  // [optional] ID of the node where the shard is located.
  optional string node = 2;

  // [required] Provides details about the error that caused the shard failure.
  ErrorCause reason = 3;

  // [required] The shard number where the failure occurred.
  int32 shard = 4;

  // [optional] Error status.
  optional string status = 5;

  // [required]
  bool primary = 6;

}

message ShardSearchFailure {

  // [optional] Name of the index in which the shard failure occurred.
  optional string index = 1;

  // [optional] ID of the node where the shard is located.
  optional string node = 2;

  // [required] Provides details about the error that caused the shard failure.
  ErrorCause reason = 3;

  // [required] The shard number where the failure occurred.
  int32 shard = 4;

  // [optional] Error status.
  optional string status = 5;
}

message QueryContainer {
  oneof query_container{
    // A Boolean (bool) query can combine several query clauses into one advanced query. The clauses are combined with Boolean logic to find matching documents returned in the results.
    BoolQuery bool = 1;

    // A boosting query returns documents that match a positive query. Among those documents, the ones that also match the negative query are scored lower in relevance (their relevance score is multiplied by the negative boosting factor).
    BoostingQuery boosting = 2;

    // A constant_score query wraps a filter query and assigns all documents in the results a relevance score equal to the value of the boost parameter.
    ConstantScoreQuery constant_score = 3;

    // A disjunction max (dis_max) query returns any document that matches one or more query clauses. For documents that match multiple query clauses, the relevance score is set to the highest relevance score from all matching query clauses.
    DisMaxQuery dis_max = 4;

    // Use a function_score query if you need to alter the relevance scores of documents returned in the results. A function_score query defines a query and one or more functions that can be applied to all results or subsets of the results to recalculate their relevance scores.
    FunctionScoreQuery function_score = 5;

    // Use the exists query to search for documents that contain a specific field.
    ExistsQuery exists = 6;

    // Fuzzy query is to searches for documents containing terms that are similar to the search term within the maximum allowed Damerau–Levenshtein distance. The Damerau–Levenshtein distance measures the number of one-character changes needed to change one term to another term.
    FuzzyQuery fuzzy = 7;

    // Use the ids query to search for documents with one or more specific document ID values in the _id field. For example, the following query requests documents with the IDs 34229 and 91296.
    IdsQuery ids = 8;

    // Prefix query is to search for terms that begin with a specific prefix.
    PrefixQuery prefix = 9;

    // Returns documents that contain terms within a provided range.
    RangeQuery range = 10;

    // Returns documents that contain terms matching a regular expression.
    RegexpQuery regexp = 11;

    // Term query is to search for an exact term in a field. The term query does not analyze the search term. The term query only searches for the exact term you provide.
    TermQuery term = 12;

    // Terms query field is to search for documents containing one or more terms in a specific field. Use the terms query to search for multiple terms in the same field.
    TermsQuery terms = 13;

    // terms set query is to search for documents that match a minimum number of exact terms in a specified field. A terms_set query is similar to a terms query, except that you can specify the minimum number of matching terms that are required in order to return a document. You can specify this number either in a field in the index or with a script.
    TermsSetQuery terms_set = 14;

    // Returns documents that contain terms matching a wildcard pattern.
    WildcardQuery wildcard = 15;

    // Use the match query for full-text search on a specific document field. If you run a match query on a text field, the match query analyzes the provided search string and returns documents that match any of the string's terms. If you run a match query on an exact-value field, it returns documents that match the exact value. The preferred way to search exact-value fields is to use a filter because, unlike a query, a filter is cached.
    MatchQuery match = 16;

    // The match_bool_prefix query analyzes the provided search string and creates a Boolean query from the string's terms. It uses every term except the last term as a whole word for matching. The last term is used as a prefix. The match_bool_prefix query returns documents that contain either the whole-word terms or terms that start with the prefix term, in any order.
    MatchBoolPrefixQuery match_bool_prefix = 17;

    // Use the match_phrase query to match documents that contain an exact phrase in a specified order. You can add flexibility to phrase matching by providing the slop parameter.
    MatchPhraseQuery match_phrase = 18;

    // Use the match_phrase_prefix query to specify a phrase to match in order. The documents that contain the phrase you specify will be returned. The last partial term in the phrase is interpreted as a prefix, so any documents that contain phrases that begin with the phrase and prefix of the last term will be returned.
    MatchPhrasePrefixQuery match_phrase_prefix = 19;

    // A multi-match operation functions similarly to the match operation. You can use a multi_match query to search multiple fields.
    MultiMatchQuery multi_match = 20;

    // A query_string query parses the query string based on the query string syntax. It provides for creating powerful yet concise queries that can incorporate wildcards and search multiple fields.
    QueryStringQuery query_string = 21;

    // Use the simple_query_string type to specify multiple arguments delineated by regular expressions directly in the query string. Simple query string has a less strict syntax than query string because it discards any invalid portions of the string and does not return errors for invalid syntax.
    SimpleQueryStringQuery simple_query_string = 22;

    // Returns documents based on the order and proximity of matching terms.
    IntervalsQuery intervals = 23;

    // Knn query is to search for the k-nearest neighbors to a query point across an index of vectors. To determine the neighbors, you can specify the space (the distance function) you want to use to measure the distance between points.
    KnnQuery knn = 24;

    // The match all query returns all documents. This query can be useful in testing large document sets if you need to return the entire set.
    MatchAllQuery match_all = 25;

    // This is the inverse of the match_all query, which matches no documents.
    MatchNoneQuery match_none = 26;

    // Use a script_score query to customize the score calculation by using a script. For an expensive scoring function, you can use a script_score query to calculate the score only for the returned documents that have been filtered.
    ScriptScoreQuery script_score = 27;

    // The nested query acts as a wrapper for other queries to search nested fields. The nested field objects are searched as though they were indexed as separate documents. If an object matches the search, the nested query returns the parent document at the root level.
    NestedQuery nested = 28;

    // A geodistance query returns documents with geopoints that are within a specified distance from the provided geopoint. A document with multiple geopoints matches the query if at least one geopoint matches the query.
    GeoDistanceQuery geo_distance = 29;

    // To search for documents that contain geopoint fields, use a geo-bounding box query. The geo-bounding box query returns documents whose geopoints are within the bounding box specified in the query. A document with multiple geopoints matches the query if at least one geopoint is within the bounding box.
    GeoBoundingBoxQuery geo_bounding_box = 30;

    // To filter documents based on a custom condition written in the Painless scripting language.
    ScriptQuery script = 31;
  }
}

message ScriptQuery {
  // [required]
  Script script = 1;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;
  // [optional] Query name for query tagging.
  optional string x_name = 3;

}

message GeoBoundingBoxQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;
  // [optional] The name of the filter.
  optional string x_name = 2;
  // [optional]
  optional GeoExecution type = 3;
  // [optional] The validation method. Valid values are IGNORE_MALFORMED (accept geopoints with invalid coordinates), COERCE (try to coerce coordinates to valid values), and STRICT (return an error when coordinates are invalid). Default is STRICT.
  optional GeoValidationMethod validation_method = 4;
  // [optional] Specifies whether to ignore an unmapped field. If set to true, the query does not return any documents that have an unmapped field. If set to false, an exception is thrown when the field is unmapped. Default is false.
  optional bool ignore_unmapped = 5;
  // [optional]
  map<string, GeoBounds> bounding_box = 6;
}

message GeoBounds {
  oneof geo_bounds {
    // The bounds specified using coordinate values.
    CoordsGeoBounds coords = 1;

    // The bounds specified using upper-left and lower-right points.
    TopLeftBottomRightGeoBounds tlbr = 2;

    // The bounds specified using upper-right and lower-left points.
    TopRightBottomLeftGeoBounds trbl = 3;

    // The bounds specified using WKT format.
    WktGeoBounds wkt = 4;
  }
}

message WktGeoBounds {
  // [required] The WKT string representation of the geographical bounds.
  string wkt = 1;
}

message CoordsGeoBounds {
  // [required] The top boundary latitude.
  double top = 1;

  // [required] The bottom boundary latitude.
  double bottom = 2;

  // [required] The left boundary longitude.
  double left = 3;

  // [required] The right boundary longitude.
  double right = 4;
}

message TopLeftBottomRightGeoBounds {
  // [required] The upper-left corner coordinates.
  GeoLocation top_left = 1;

  // [required] The lower-right corner coordinates.
  GeoLocation bottom_right = 2;
}

message TopRightBottomLeftGeoBounds {
  // [required] The upper-right corner coordinates.
  GeoLocation top_right = 1;

  // [required] The lower-left corner coordinates.
  GeoLocation bottom_left = 2;
}

enum GeoExecution {
  GEO_EXECUTION_UNSPECIFIED = 0;
  GEO_EXECUTION_INDEXED = 1;
  GEO_EXECUTION_MEMORY = 2;
}

message GeoDistanceQuery {
  // [required] The distance within which to match the points. This distance is the radius of a circle centered at the specified point. For supported distance units, see Distance units.
  string distance = 1;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;
  // [optional] The name of the filter.
  optional string x_name = 3;
  // [optional] Specifies how to calculate the distance. Valid values are arc or plane (faster but inaccurate for long distances or points close to the poles).
  optional GeoDistanceType distance_type = 4;
  // [optional] The validation method. Valid values are IGNORE_MALFORMED (accept geopoints with invalid coordinates), COERCE (try to coerce coordinates to valid values), and STRICT (return an error when coordinates are invalid). Default is STRICT.
  optional GeoValidationMethod validation_method = 5;
  // [optional] Set to `true` to ignore an unmapped field and not match any documents for this query. Set to `false` to throw an exception if the field is not mapped.
  optional bool ignore_unmapped = 6;
  // [optional] The unit of distance measurement.
  optional DistanceUnit unit = 7;
  // [optional]
  map<string, GeoLocation> location = 8;
}

enum DistanceUnit {
  DISTANCE_UNIT_UNSPECIFIED = 0;
  DISTANCE_UNIT_CM = 1;
  DISTANCE_UNIT_FT = 2;
  DISTANCE_UNIT_IN = 3;
  DISTANCE_UNIT_KM = 4;
  DISTANCE_UNIT_M = 5;
  DISTANCE_UNIT_MI = 6;
  DISTANCE_UNIT_MM = 7;
  DISTANCE_UNIT_NMI = 8;
  DISTANCE_UNIT_YD = 9;
}

message TermsQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // [optional] Specifies the types of values used for filtering. Valid values are `default` and `bitmap`. Default is `default`.
  optional TermsQueryValueType value_type = 3;

  // [optional]
  map<string, TermsQueryField> terms = 4;
}

message NestedQuery {
  // [required] The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  string path = 1;
  // [required] The query to run on the nested objects within the specified path.
  QueryContainer query = 2;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;
  // [optional] Query name for query tagging.
  optional string x_name = 4;
  // [optional] Set to `true` to ignore an unmapped field and not match any documents for this query. Set to `false` to throw an exception if the field is not mapped.
  optional bool ignore_unmapped = 5;
  // [optional] If provided, returns the underlying hits that matched the query.
  optional InnerHits inner_hits = 6;
  // [optional] Defines how scores of matching inner documents influence the parent document’s score
  optional ChildScoreMode score_mode = 7;
}

enum ChildScoreMode {
  CHILD_SCORE_MODE_UNSPECIFIED = 0;
  CHILD_SCORE_MODE_AVG = 1;
  CHILD_SCORE_MODE_MAX = 2;
  CHILD_SCORE_MODE_MIN = 3;
  CHILD_SCORE_MODE_NONE = 4;
  CHILD_SCORE_MODE_SUM = 5;
}

message InnerHits {

  // [optional] The name to be used for the particular inner hit definition in the response. Useful when multiple inner hits have been defined in a single search request.
  optional string name = 1;

  // [optional] The maximum number of hits to return per `inner_hits`.
  optional int32 size = 2;

  // [optional] Inner hit starting document offset.
  optional int32 from = 3;

  // [optional] The collapse parameter groups search results by a particular field value. This returns only the top document within each group, which helps reduce redundancy by eliminating duplicates.
  optional FieldCollapse collapse = 4;

  // [optional] The fields that OpenSearch should return using their docvalue forms. Specify a format to return results in a certain format, such as date and time.
  repeated FieldAndFormat docvalue_fields = 5;

  // [optional] Whether to return details about how OpenSearch computed the document's score. Default is false.
  optional bool explain = 6;

  // [optional] Highlighting emphasizes the search term(s) in the results so you can emphasize the query matches.
  optional Highlight highlight = 7;

  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  optional bool ignore_unmapped = 8;

  // [optional] The script_fields parameter allows you to include custom fields whose values are computed using scripts in your search results. This can be useful for calculating values dynamically based on the document data. You can also retrieve derived fields by using a similar approach.
  map<string, ScriptField> script_fields = 9;

  // [optional] Whether to return sequence number and primary term of the last operation of each document hit.
  optional bool seq_no_primary_term = 10;

  // [optional] Retrieve selected fields from a search
  repeated FieldAndFormat fields = 11;

  // [optional] How the inner hits should be sorted per inner_hits. By default the hits are sorted by the score.
  repeated SortCombinations sort = 12;

  // [optional] Select what fields of the source are returned
  optional SourceConfig x_source = 13;

  // [optional] A list of stored fields to return as part of a hit. If no fields are specified, no stored fields are included in the response. If this option is specified, the _source parameter defaults to false. You can pass _source: true to return both source fields and stored fields in the search response.
  repeated string stored_fields = 14;

  // [optional] Whether to return document scores. Default is false.
  optional bool track_scores = 15;

  // [optional] Whether to include the document version as a match.
  optional bool version = 16;

}

message ScriptField {
  Script script = 1;
  optional bool ignore_failure = 2;
}

message HighlighterType {
  oneof highlighter_type {
    BuiltinHighlighterType builtin = 1;

    string custom = 2;
  }
}

enum BuiltinHighlighterType {
  BUILTIN_HIGHLIGHTER_TYPE_UNSPECIFIED = 0;
  BUILTIN_HIGHLIGHTER_TYPE_PLAIN = 1;
  BUILTIN_HIGHLIGHTER_TYPE_FVH = 2;
  BUILTIN_HIGHLIGHTER_TYPE_UNIFIED = 3;
}

enum BoundaryScanner {
  BOUNDARY_SCANNER_UNSPECIFIED = 0;
  BOUNDARY_SCANNER_CHARS = 1;
  BOUNDARY_SCANNER_SENTENCE = 2;
  BOUNDARY_SCANNER_WORD = 3;
}

enum HighlighterFragmenter {
  HIGHLIGHTER_FRAGMENTER_UNSPECIFIED = 0;
  HIGHLIGHTER_FRAGMENTER_SIMPLE = 1;
  HIGHLIGHTER_FRAGMENTER_SPAN = 2;
}

enum HighlighterOrder {
  HIGHLIGHTER_ORDER_UNSPECIFIED = 0;
  HIGHLIGHTER_ORDER_SCORE = 1;
}

enum HighlighterTagsSchema {
  HIGHLIGHTER_TAGS_SCHEMA_UNSPECIFIED = 0;
  HIGHLIGHTER_TAGS_SCHEMA_STYLED = 1;
}

message SortCombinations {

  oneof sort_combinations {
    // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
    string field = 1;
    SortOrderMap field_with_direction = 2;
    FieldSortMap field_with_order = 3;
    SortOptions options = 4;
  }
}

message SortOrderMap {

  map<string, SortOrder> sort_order_map = 1;

}

message FieldSortMap {

  map<string, FieldSort> field_sort_map = 1;

}

message SortOptions {
  oneof sort_options{
    ScoreSort x_score = 1;

    GeoDistanceSort x_geo_distance = 2;

    ScriptSort x_script = 3;
  }
}

enum HighlighterEncoder {
  HIGHLIGHTER_ENCODER_UNSPECIFIED = 0;
  // No encoding
  HIGHLIGHTER_ENCODER_DEFAULT = 1;
  // First escape the HTML text and then insert the highlighting tags
  HIGHLIGHTER_ENCODER_HTML = 2;
}

message Highlight {
  // [optional] Specifies the highlighter to use. Default is unified.
  optional HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  optional string boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  optional int32 boundary_max_scan = 3;

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  optional BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  optional string boundary_scanner_locale = 5;

  // [x-deprecated]
  optional bool force_source = 6;

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  optional HighlighterFragmenter fragmenter = 7;
  // [optional]
  optional int32 fragment_offset = 8;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  optional int32 fragment_size = 9;

  // [optional]
  optional bool highlight_filter = 10;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  optional QueryContainer highlight_query = 11;

  // [optional]
  optional int32 max_fragment_length = 12;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  optional int32 max_analyzed_offset = 13;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  optional int32 no_match_size = 14;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  optional int32 number_of_fragments = 15;

  optional ObjectMap options = 16;

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  optional HighlighterOrder order = 17;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  optional int32 phrase_limit = 18;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 19;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 20;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  optional bool require_field_match = 21;

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  optional HighlighterTagsSchema tags_schema = 22;

  // [optional] Specifies whether the highlighted fragment should be HTML encoded before it is returned.
  optional HighlighterEncoder encoder = 23;

  // [required] Specifies the fields to search for text to be highlighted. Supports wildcard expressions. If you use wildcards, only text and keyword fields are highlighted. For example, you can set fields to my_field* to include all text and keyword fields that start with the prefix my_field.
  map<string, HighlightField> fields = 24;

}

message HighlightField {
  // [optional] Specifies the highlighter to use. Default is unified.
  optional HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  optional string boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  optional int32 boundary_max_scan = 3;

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  optional BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  optional string boundary_scanner_locale = 5;

  // [x-deprecated]
  bool force_source = 6;

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  optional HighlighterFragmenter fragmenter = 7;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  optional int32 fragment_size = 8;

  optional bool highlight_filter = 9;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  optional QueryContainer highlight_query = 10;

  optional int32 max_fragment_length = 11;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  optional int32 max_analyzed_offset = 12;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  optional int32 no_match_size = 13;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  optional int32 number_of_fragments = 14;
  // [optional]
  optional ObjectMap options = 15;

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  optional HighlighterOrder order = 16;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  optional int32 phrase_limit = 17;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 18;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 19;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  optional bool require_field_match = 20;
  // [optional]
  optional HighlighterTagsSchema tags_schema = 21;

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  optional int32 fragment_offset = 22;

  // [optional] Combines matches from different fields to highlight one field. The most common use case for this functionality is highlighting text that is analyzed in different ways and kept in multi-fields. All fields in the matched_fields list must have the term_vector field set to with_positions_offsets. The field in which the matches are combined is the only loaded field, so it is beneficial to set its store option to yes. Valid only for the fvh highlighter.
  repeated string matched_fields = 23;

}

message FieldWithOrderMap {
  // [required] Map of fields and their corresponding sort order.
  map<string, ScoreSort> field_with_order_map = 1;
}

message FieldSort {
  // The value to use when the field is missing.
  optional FieldValue missing = 1;

  // The mode for sorting on array fields.
  optional SortMode mode = 2;

  // The nested path sort options.
  optional NestedSortValue nested = 3;

  // The sort order direction.
  optional SortOrder order = 4;

  // The type to use for unmapped fields.
  optional FieldType unmapped_type = 5;

  // The numeric type to use for sorting.
  optional FieldSortNumericType numeric_type = 6;
}

enum FieldSortNumericType {
  FIELD_SORT_NUMERIC_TYPE_UNSPECIFIED = 0;
  FIELD_SORT_NUMERIC_TYPE_DATE = 1;
  FIELD_SORT_NUMERIC_TYPE_DATE_NANOS = 2;
  FIELD_SORT_NUMERIC_TYPE_DOUBLE = 3;
  FIELD_SORT_NUMERIC_TYPE_LONG = 4;
}

enum FieldType {
  FIELD_TYPE_UNSPECIFIED = 0;
  FIELD_TYPE_AGGREGATE_METRIC_DOUBLE = 1;
  FIELD_TYPE_ALIAS = 2;
  FIELD_TYPE_BINARY = 3;
  FIELD_TYPE_BOOLEAN = 4;
  FIELD_TYPE_BYTE = 5;
  FIELD_TYPE_COMPLETION = 6;
  FIELD_TYPE_CONSTANT_KEYWORD = 7;
  FIELD_TYPE_DATE = 8;
  FIELD_TYPE_DATE_NANOS = 9;
  FIELD_TYPE_DATE_RANGE = 10;
  FIELD_TYPE_DOUBLE = 11;
  FIELD_TYPE_DOUBLE_RANGE = 12;
  FIELD_TYPE_FLAT_OBJECT = 13;
  FIELD_TYPE_FLOAT = 14;
  FIELD_TYPE_FLOAT_RANGE = 15;
  FIELD_TYPE_GEO_POINT = 16;
  FIELD_TYPE_GEO_SHAPE = 17;
  FIELD_TYPE_HALF_FLOAT = 18;
  FIELD_TYPE_HISTOGRAM = 19;
  FIELD_TYPE_ICU_COLLATION_KEYWORD = 20;
  FIELD_TYPE_INTEGER = 21;
  FIELD_TYPE_INTEGER_RANGE = 22;
  FIELD_TYPE_IP = 23;
  FIELD_TYPE_IP_RANGE = 24;
  FIELD_TYPE_JOIN = 25;
  FIELD_TYPE_KEYWORD = 26;
  FIELD_TYPE_KNN_VECTOR = 27;
  FIELD_TYPE_LONG = 28;
  FIELD_TYPE_LONG_RANGE = 29;
  FIELD_TYPE_MATCH_ONLY_TEXT = 30;
  FIELD_TYPE_MURMUR3 = 31;
  FIELD_TYPE_NESTED = 32;
  FIELD_TYPE_OBJECT = 33;
  FIELD_TYPE_PERCOLATOR = 34;
  FIELD_TYPE_RANK_FEATURE = 35;
  FIELD_TYPE_RANK_FEATURES = 36;
  FIELD_TYPE_SCALED_FLOAT = 37;
  FIELD_TYPE_SEARCH_AS_YOU_TYPE = 38;
  FIELD_TYPE_SHORT = 39;
  FIELD_TYPE_TEXT = 40;
  FIELD_TYPE_TOKEN_COUNT = 41;
  FIELD_TYPE_UNSIGNED_LONG = 42;
  FIELD_TYPE_VERSION = 43;
  FIELD_TYPE_WILDCARD = 44;
  FIELD_TYPE_XY_POINT = 45;
  FIELD_TYPE_XY_SHAPE = 46;
}

message ScoreSort {
  // Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 1;
}

enum SortOrder {
  SORT_ORDER_UNSPECIFIED = 0;
  // Sort in ascending order.
  SORT_ORDER_ASC = 1;
  // Sort in descending order
  SORT_ORDER_DESC = 2;
}

enum SortMode {
  SORT_MODE_UNSPECIFIED = 0;
  SORT_MODE_AVG = 1;
  SORT_MODE_MAX = 2;
  SORT_MODE_MEDIAN = 3;
  SORT_MODE_MIN = 4;
  SORT_MODE_SUM = 5;
}

enum GeoDistanceType {
  GEO_DISTANCE_TYPE_UNSPECIFIED = 0;
  GEO_DISTANCE_TYPE_ARC = 1;
  GEO_DISTANCE_TYPE_PLANE = 2;
}

message GeoDistanceSort {

  // [optional] Specifies how to handle a field with several geopoints.
  optional SortMode mode = 1;
  // [optional] Specifies the method of computing the distance.
  optional GeoDistanceType distance_type = 2;
  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  optional bool ignore_unmapped = 3;
  // [optional]
  optional NestedSortValue nested = 4;
  // [optional] Specifies the sort order (asc or dsc) for the score.
  optional SortOrder order = 5;
  // [optional] Specifies the units used to compute sort values. Default is meters (m).
  optional DistanceUnit unit = 6;
  // [optional]
  optional GeoValidationMethod validation_method = 7;
  // [optional]
  map<string, GeoLocationArray> location = 8;
}


message GeoLocationArray {
  // The geo points to use for distance calculation.
  repeated GeoLocation geo_location_array = 1;

}

enum GeoValidationMethod {
  GEO_VALIDATION_METHOD_UNSPECIFIED = 0;
  GEO_VALIDATION_METHOD_COERCE = 1;
  GEO_VALIDATION_METHOD_IGNORE_MALFORMED = 2;
  GEO_VALIDATION_METHOD_STRICT = 3;
}

enum ScriptSortType {
  SCRIPT_SORT_TYPE_UNSPECIFIED = 0;
  SCRIPT_SORT_TYPE_NUMBER = 1;
  SCRIPT_SORT_TYPE_STRING = 2;
  SCRIPT_SORT_TYPE_VERSION = 3;
}


message ScriptSort {
  // [required] The script to execute for custom sorting.
  Script script = 1;
  // [optional] Specifies the sort order (asc or dsc) for the score.
  optional SortOrder order = 2;
  // [optional] Specifies script sort type.
  optional ScriptSortType type = 3;
  // [optional] Specifies what array value should be chosen for sorting the document.
  optional SortMode mode = 4;
  // [optional] Supports sorting by fields that are inside one or more nested objects.
  optional NestedSortValue nested = 5;

}

message NestedSortValue {

  // [required] Specifies the path to the field on which to sort.
  string path = 1;
  // [optional] A filter that the inner objects inside the nested path should match with in order for its field values to be taken into account by sorting. Common case is to repeat the query / filter inside the nested filter or query. By default no filter is active.
  optional QueryContainer filter = 2;
  // [optional] The maximum number of children to consider per root document when picking the sort value. Defaults to unlimited.
  optional int32 max_children = 3;
  // [optional] Same as top-level nested but applies to another nested path within the current nested object.
  optional NestedSortValue nested = 4;

}

message FieldAndFormat {

  // [required] Wildcard pattern. The request returns doc values for field names matching this pattern.
  string field = 1;

  // [optional] Format in which the values are returned.
  optional string format = 2;

}

message FieldCollapse {

  // [required] The document field by which you want to group or collapse the search results
  string field = 1;

  // [optional] Expanding each group uses an additional query for each inner_hit request for every collapsed hit in the response.
  repeated InnerHits inner_hits = 2;

  // [optional] Use to control the maximum number of concurrent searches allowed in this phase.
  optional int32 max_concurrent_group_searches = 3;

}

message ScriptScoreQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // Documents with a score lower than this floating point number are excluded from the search results.
  float min_score = 3;

  QueryContainer query = 4;

  Script script = 5;

}

message ExistsQuery {
  // [required] Name of the field you wish to search.
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;
}

enum Operator {
  OPERATOR_UNSPECIFIED = 0;
  OPERATOR_AND = 1;
  OPERATOR_OR = 2;
}

message SimpleQueryStringQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // Analyzer used to convert text in the query string into tokens.
  string analyzer = 3;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  bool analyze_wildcard = 4;

  // If `true`, the parser creates a match_phrase query for each multi-position token.
  bool auto_generate_synonyms_phrase_query = 5;

  Operator default_operator = 6;

  repeated string fields = 7;

  SimpleQueryStringFlags flags = 8;

  // Maximum number of terms to which the query expands for fuzzy matching.
  int32 fuzzy_max_expansions = 9;

  // Number of beginning characters left unchanged for fuzzy matching.
  int32 fuzzy_prefix_length = 10;

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool fuzzy_transpositions = 11;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  bool lenient = 12;

  MinimumShouldMatch minimum_should_match = 13;
  // Query string in the simple query string syntax you wish to parse and use for search.
  string query = 14;

  // Suffix appended to quoted text in the query string.
  string quote_field_suffix = 15;

}

message WildcardQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] The name of the query for query tagging.
  optional string x_name = 3;

  // [optional] Allows case insensitive matching of the pattern with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  optional bool case_insensitive = 4;

  optional MultiTermQueryRewrite rewrite = 5;

  // [optional] Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.
  optional string value = 6;

  // [optional] Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.
  optional string wildcard = 7;

}

enum MultiTermQueryRewrite {
  MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
  MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
  MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
  MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
  MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
  MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
  MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
}

message SimpleQueryStringFlags {
  oneof simple_query_string_flags {
    SimpleQueryStringFlag single = 1;

    string multiple = 2;
  }
}

enum SimpleQueryStringFlag {
  SIMPLE_QUERY_STRING_FLAG_UNSPECIFIED = 0;
  SIMPLE_QUERY_STRING_FLAG_ALL = 1;
  SIMPLE_QUERY_STRING_FLAG_AND = 2;
  SIMPLE_QUERY_STRING_FLAG_ESCAPE = 3;
  SIMPLE_QUERY_STRING_FLAG_FUZZY = 4;
  SIMPLE_QUERY_STRING_FLAG_NEAR = 5;
  SIMPLE_QUERY_STRING_FLAG_NONE = 6;
  SIMPLE_QUERY_STRING_FLAG_NOT = 7;
  SIMPLE_QUERY_STRING_FLAG_OR = 8;
  SIMPLE_QUERY_STRING_FLAG_PHRASE = 9;
  SIMPLE_QUERY_STRING_FLAG_PRECEDENCE = 10;
  SIMPLE_QUERY_STRING_FLAG_PREFIX = 11;
  SIMPLE_QUERY_STRING_FLAG_SLOP = 12;
  SIMPLE_QUERY_STRING_FLAG_WHITESPACE = 13;
}

message KnnQuery {
  // [required] Specifies the vector field against which to run a search query
  string field = 1;

  // [optional]
  // Query vector. Must have the same number of dimensions as the vector field you are searching against.
  repeated float vector = 2;

  // [optional]
  // The final number of nearest neighbors to return as top hits.
  optional int32 k = 3;

  // [optional]
  // The minimum similarity score for a neighbor to be considered a hit.
  optional float min_score = 4;

  // [optional]
  // The maximum physical distance in vector space for a neighbor to be considered a hit.
  optional float max_distance = 5;

  // [optional]
  // Filters for the kNN search query. The kNN search will return the top k documents that also match this filter. If filter is not provided, all documents are allowed to match.
  optional QueryContainer filter = 6;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 7;

  // [optional] Query name for query tagging.
  optional string x_name = 8;

  // [optional]
  // Method parameters are dependent on the combination of engine and method used to create the index.
  // Available method ef_search see https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#ef_search and nprobes "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#nprobes"
  optional ObjectMap method_parameters = 9;

  // [optional]
  // Available in version later than 2.17
  // To explicitly apply rescoring, provide the rescore parameter in a query on a quantized index and specify the oversample_factor "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#rescoring-quantized-results-using-full-precision"
  optional KnnQueryRescore rescore = 10;

  // [optional] When true, retrieves scores for all nested field documents within each parent document. Used with nested queries. For more information, see Vector search with nested fields.
  optional bool expand_nested_docs = 11;

}

message RescoreContext {
  optional float oversample_factor = 1;
}

message KnnQueryRescore {
  oneof knn_query_rescore {
    bool enable = 1;

    RescoreContext context = 2;
  }
}

message MatchQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [required] The query string to use for search.
  FieldValue query = 2;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;
  // [optional] Query name for query tagging.
  optional string x_name = 4;
  // [optional] The analyzer used to tokenize the query string text. Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  optional string analyzer = 5;
  // [optional] Specifies whether to create a match phrase query automatically for multi-term synonyms. For example, if you specify ba,batting average as synonyms and search for ba, OpenSearch searches for ba OR "batting average" (if this option is true) or ba OR (batting AND average) (if this option is false).
  optional bool auto_generate_synonyms_phrase_query = 6;
  // [optional] The number of character edits (insertions, deletions, substitutions, or transpositions) that it takes to change one word to another when determining whether a term matched a value. For example, the distance between wined and wind is 1. Valid values are non-negative integers or AUTO.
  optional Fuzziness fuzziness = 7;
  // [optional] Determines how OpenSearch rewrites the query. Default is constant_score.
  optional MultiTermQueryRewrite fuzzy_rewrite = 8;
  // [optional] Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option. For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo. The default(true) is a good choice for most use cases.
  optional bool fuzzy_transpositions = 9;
  // [optional] Setting lenient to true ignores data type mismatches between the query and the document field. For example, a query string of "8.2" could match a field of type float. Default is false.
  optional bool lenient = 10;
  // [optional] The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  optional int32 max_expansions = 11;
  // [optional] If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match. For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  optional MinimumShouldMatch minimum_should_match = 12;
  // [optional] If the query string contains multiple search terms, whether all terms need to match (AND) or only one term needs to match (OR) for a document to be considered a match. Default is OR.
  optional Operator operator = 13;
  // [optional] The number of leading characters that are not considered in fuzziness. Default is 0.
  optional int32 prefix_length = 14;
  // [optional] In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all. Default is none.
  optional ZeroTermsQuery zero_terms_query = 15;
}

message Query {
  oneof query{
    // if the query value is string type.
    string string = 1;
    // if the query value is number type.
    GeneralNumber general_number = 2;
    // if the query value is boolean type.
    bool bool = 3;
  }
}

message BoolQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] The name of the query for query tagging.
  optional string x_name = 2;

  // [optional] The clause (query) must appear in matching documents. However, unlike `must`, the score of the query will be ignored.
  repeated QueryContainer filter = 3;

  // [optional]
  optional MinimumShouldMatch minimum_should_match = 4;

  // [optional]The clause (query) must appear in matching documents and will contribute to the score.
  repeated QueryContainer must = 5;

  // [optional] The clause (query) must not appear in the matching documents. Because scoring is ignored, a score of `0` is returned for all documents.
  repeated QueryContainer must_not = 6;

  // [optional] The clause (query) should appear in the matching document.
  repeated QueryContainer should = 7;

  // [optional] Ensures correct behavior when a query contains only `must_not` clauses. By default set to true, OpenSearch adds a match-all clause to ensure results are returned from Lucene, with the `must_not` conditions applied as filters. If set to false, the query may return no results, as Lucene typically requires at least one positive condition.
  optional bool adjust_pure_negative = 8;
}

message MinimumShouldMatch{
  oneof minimum_should_match{
    // if minimum_should_match is integer type. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    int32 int32 = 1;
    // if minimum_should_match is string type like percentage or combinations. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    string string = 2;
  }
}

message BoostingQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.
  float negative_boost = 3;

  QueryContainer negative = 4;

  QueryContainer positive = 5;

}

message ConstantScoreQuery {
  // [required] The filter query that a document must match to be returned in the results.
  QueryContainer filter = 1;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;
  // [optional] Query name for query tagging.
  optional string x_name = 3;
}

message DisMaxQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // One or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, OpenSearch uses the highest relevance score.
  repeated QueryContainer queries = 3;

  // Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.
  float tie_breaker = 4;

}

message FunctionScoreQuery {
  // [required] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;
  // [optional] Query name for query tagging.
  optional string x_name = 2;
  // [optional] how the score computed using all functions is combined with the query score.
  optional FunctionBoostMode boost_mode = 3;
  // [optional] One or more functions that compute a new score for each document returned by the query.
  repeated FunctionScoreContainer functions = 4;
  // [optional] Restricts the new score to not exceed the provided limit.
  optional float max_boost = 5;
  // [optional] Excludes documents that do not meet the provided score threshold.
  optional float min_score = 6;
  // [optional]
  optional QueryContainer query = 7;
  // [optional] Specifies how the computed scores are combined
  optional FunctionScoreMode score_mode = 8;

}

enum FunctionBoostMode {
  FUNCTION_BOOST_MODE_UNSPECIFIED = 0;
  FUNCTION_BOOST_MODE_AVG = 1;
  FUNCTION_BOOST_MODE_MAX = 2;
  FUNCTION_BOOST_MODE_MIN = 3;
  FUNCTION_BOOST_MODE_MULTIPLY = 4;
  FUNCTION_BOOST_MODE_REPLACE = 5;
  FUNCTION_BOOST_MODE_SUM = 6;
}

enum FunctionScoreMode {
  FUNCTION_SCORE_MODE_UNSPECIFIED = 0;
  FUNCTION_SCORE_MODE_AVG = 1;
  FUNCTION_SCORE_MODE_FIRST = 2;
  FUNCTION_SCORE_MODE_MAX = 3;
  FUNCTION_SCORE_MODE_MIN = 4;
  FUNCTION_SCORE_MODE_MULTIPLY = 5;
  FUNCTION_SCORE_MODE_SUM = 6;
}

message IntervalsAllOf {

  // An array of rules to combine. All rules must produce a match in a document for the overall source to match.
  repeated IntervalsContainer intervals = 1;

  // Maximum number of positions between the matching terms. Intervals produced by the rules further apart than this are not considered matches.
  int32 max_gaps = 2;

  // If `true`, intervals produced by the rules should appear in the order in which they are specified.
  bool ordered = 3;

  IntervalsFilter filter = 4;

}

message IntervalsAnyOf {

  // An array of rules to match.
  repeated IntervalsContainer intervals = 1;

  IntervalsFilter filter = 2;

}

message IntervalsMatch {

  // Analyzer used to analyze terms in the query.
  string analyzer = 1;

  // Maximum number of positions between the matching terms. Terms further apart than this are not considered matches.
  int32 max_gaps = 2;

  // If `true`, matching terms must appear in their specified order.
  bool ordered = 3;

  // Text you wish to find in the provided field.
  string query = 4;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 5;

  IntervalsFilter filter = 6;

}

message IntervalsQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  oneof intervals_query {
    IntervalsAllOf all_of = 4;

    IntervalsAnyOf any_of = 5;

    IntervalsFuzzy fuzzy = 6;

    IntervalsMatch match = 7;

    IntervalsPrefix prefix = 8;

    IntervalsWildcard wildcard = 9;
  }

}

message FunctionScoreContainer {
  // [optional]
  optional QueryContainer filter = 1;
  // [optional]  allows you to multiply the score by the provided weight
  optional float weight = 2;

  oneof function_score_container {
    // Exponential decay
    DecayFunction exp = 3;
    // Normal decay
    DecayFunction gauss = 4;
    // Linear decay
    DecayFunction linear = 5;
    // Allows you to use a field from a document to influence the score
    FieldValueFactorScoreFunction field_value_factor = 6;
    // Generates scores that are uniformly distributed from 0 up to but not including 1
    RandomScoreFunction random_score = 7;
    // Allows you to wrap another query and customize the scoring of it optionally with a computation derived from other numeric field values in the doc using a script expression
    ScriptScoreFunction script_score = 8;
  }
}

message DecayFunction {
  // [optional] specify for decay calculation contains multiple values
  optional MultiValueMode multi_value_mode = 1;

  // [required] Decay functions score a document with a function that decays depending on the distance of a numeric field value of the document from a user given origin
  map<string, DecayPlacement> placement = 2;

}

message DecayPlacement {
  oneof decay_placement {

    DateDecayPlacement date_decay_placement = 1;

    GeoDecayPlacement geo_decay_placement = 2;

    NumericDecayPlacement numeric_decay_placement = 3;

  }
}

message DateDecayPlacement {
  // [required] Defines the distance from origin + offset at which the computed score will equal decay parameter
  string scale = 1;
  // [optional] The decay parameter defines how documents are scored at the distance given at scale
  optional double decay = 2;
  // [optional] If an offset is defined, the decay function will only compute the decay function for documents with a distance greater than the defined offset.
  optional string offset = 3;
  // [optional] The decay function will only compute the decay function for documents with a distance greater than the defined
  optional string origin = 4;

}

message GeoDecayPlacement {
  // [required] Defines the distance from origin + offset at which the computed score will equal decay parameter
  string scale = 1;
  // [required] The point of origin used for calculating distance
  GeoLocation origin = 2;
  // [optional] The decay parameter defines how documents are scored at the distance given at scale
  optional double decay = 3;
  // [optional] The decay function will only compute the decay function for documents with a distance greater than the defined
  optional string offset = 4;
}

message NumericDecayPlacement {
  // [required] Defines the distance from origin + offset at which the computed score will equal decay parameter
  double scale = 1;
  // [required] The point of origin used for calculating distance
  double origin = 2;
  // [optional] The decay parameter defines how documents are scored at the distance given at scale
  optional double decay = 3;
  // [optional] The decay function will only compute the decay function for documents with a distance greater than the defined
  optional double offset = 4;
}

enum MultiValueMode {
  MULTI_VALUE_MODE_UNSPECIFIED = 0;
  MULTI_VALUE_MODE_AVG = 1;
  MULTI_VALUE_MODE_MAX = 2;
  MULTI_VALUE_MODE_MIN = 3;
  MULTI_VALUE_MODE_SUM = 4;
}

message ScriptScoreFunction {

  Script script = 1;

}

message IntervalsFilter {
  oneof intervals_filter {
    IntervalsContainer after = 1;

    IntervalsContainer before = 2;

    IntervalsContainer contained_by = 3;

    IntervalsContainer containing = 4;

    IntervalsContainer not_contained_by = 5;

    IntervalsContainer not_containing = 6;

    IntervalsContainer not_overlapping = 7;

    IntervalsContainer overlapping = 8;

    Script script = 9;
  }

}

message IntervalsContainer {

  oneof intervals_container {
    IntervalsAllOf all_of = 1;

    IntervalsAnyOf any_of = 2;

    IntervalsFuzzy fuzzy = 3;

    IntervalsMatch match = 4;

    IntervalsPrefix prefix = 5;

    IntervalsWildcard wildcard = 6;
  }

}

message PrefixQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [required] The term to search for in the field specified in <field>.
  string value = 2;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;
  // [optional] Query name for query tagging.
  optional string x_name = 4;
  // [optional] Determines how OpenSearch rewrites the query. Default is constant_score.
  optional MultiTermQueryRewrite rewrite = 5;
  // [optional] Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  optional bool case_insensitive = 6;
}

message TermsLookupFieldStringArrayMap {
  oneof terms_lookup_field_string_array_map {
    // terms_lookup_field terms you wish to find in the provided field
    TermsLookupField terms_lookup_field = 1;
    // string_array terms value you wish to find in the provided field
    StringArray string_array = 2;
  }
}

enum ValueType {
    VALUE_TYPE_UNSPECIFIED = 0;
    VALUE_TYPE_BITMAP = 1;
    VALUE_TYPE_DEFAULT = 2;
}

enum TermsQueryValueType {
  TERMS_QUERY_VALUE_TYPE_UNSPECIFIED = 0;
  TERMS_QUERY_VALUE_TYPE_BITMAP = 1;
  TERMS_QUERY_VALUE_TYPE_DEFAULT = 2;
}

message TermsQueryField {
  oneof terms_query_field {
    FieldValueArray field_value_array = 1;

    TermsLookup lookup = 2;
  }
}

message TermsLookup {
  string index = 1;

  // The unique identifier for a resource.
  string id = 2;

  // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  string path = 3;

  // The routing value for the document.
  optional string routing = 4;

  optional bool store = 5;
}

message FieldValueArray {
  repeated FieldValue field_value_array = 1;
}

message TermsLookupField {

  // [required]
  // The name of the index from which to fetch field values
  string index = 1;

  // [required]
  // The document ID of the document from which to fetch field values.
  string id = 2;

  // [required]
  // The name of the field from which to fetch field values. Specify nested fields using dot path notation
  string path = 3;

  // [optional]
  // Custom routing value of the document from which to fetch term values. If a custom routing value was provided when the document was indexed, this parameter is required.
  optional string routing = 4;

  // [optional]
  optional bool store = 5;

}

message TermsSetQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [required] The array of terms to search for in the field specified in <field>. A document is returned in the results only if the required number of terms matches the document's field values exactly, with the correct spacing and capitalization.
  repeated string terms = 2;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;

  // [optional] Query name for query tagging.
  optional string x_name = 4;

  // [optional] The name of the numeric field that specifies the number of matching terms required in order to return a document in the results.
  optional string minimum_should_match_field = 5;

  // [optional] A script that returns the number of matching terms required in order to return a document in the results.
  optional Script minimum_should_match_script = 6;

}

message TermQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  // [required]
  // Term you wish to find in the provided <field>. To return a document, the term must exactly match the field value, including whitespace and capitalization.
  FieldValue value = 4;

  // [optional]
  // Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. When `false`, the case sensitivity of matching depends on the underlying field's mapping.
  optional bool case_insensitive = 5;

}


message QueryStringQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  bool allow_leading_wildcard = 3;

  // Analyzer used to convert text in the query string into tokens.
  string analyzer = 4;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  bool analyze_wildcard = 5;

  // If `true`, match phrase queries are automatically created for multi-term synonyms.
  bool auto_generate_synonyms_phrase_query = 6;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string default_field = 7;

  Operator default_operator = 8;

  // If `true`, enable position increments in queries constructed from a `query_string` search.
  bool enable_position_increments = 9;

  bool escape = 10;

  repeated string fields = 11;

  Fuzziness fuzziness = 12;

  // Maximum number of terms to which the query expands for fuzzy matching.
  int32 fuzzy_max_expansions = 13;

  // Number of beginning characters left unchanged for fuzzy matching.
  int32 fuzzy_prefix_length = 14;

  MultiTermQueryRewrite fuzzy_rewrite = 15;

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool fuzzy_transpositions = 16;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  bool lenient = 17;

  // Maximum number of automaton states required for the query.
  int32 max_determinized_states = 18;

  MinimumShouldMatch minimum_should_match = 19;

  // Maximum number of positions allowed between matching tokens for phrases.
  int32 phrase_slop = 20;

  // Query string you wish to parse and use for search.
  string query = 21;

  // Analyzer used to convert quoted text in the query string into tokens. For quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.
  string quote_analyzer = 22;

  // Suffix appended to quoted text in the query string. You can use this suffix to use a different analysis method for exact matches.
  string quote_field_suffix = 23;

  MultiTermQueryRewrite rewrite = 24;

  // How to combine the queries generated from the individual search terms in the resulting `dis_max` query.
  float tie_breaker = 25;

  string time_zone = 26;

  TextQueryType type = 27;
}

enum TextQueryType {
  TEXT_QUERY_TYPE_UNSPECIFIED = 0;
  TEXT_QUERY_TYPE_BEST_FIELDS = 1;
  TEXT_QUERY_TYPE_BOOL_PREFIX = 2;
  TEXT_QUERY_TYPE_CROSS_FIELDS = 3;
  TEXT_QUERY_TYPE_MOST_FIELDS = 4;
  TEXT_QUERY_TYPE_PHRASE = 5;
  TEXT_QUERY_TYPE_PHRASE_PREFIX = 6;
}

message RandomScoreFunction {
  // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  optional string field = 1;

  optional RandomScoreFunctionSeed seed = 2;

}

message RandomScoreFunctionSeed {
  oneof random_score_function_seed {

    int32 int32 = 1;

    int64 int64 = 2;

    string string = 3;

  }
}

message RangeQuery {
  oneof range_query {
    NumberRangeQuery number_range_query = 1;

    DateRangeQuery date_range_query = 2;
  }
}

message NumberRangeQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;
  // [optional] Query name for query tagging.
  optional string x_name = 3;

  // [optional] Indicates how the range query matches values for range fields
  optional RangeRelation relation = 4;

  // [optional] Greater than.
  optional double gt = 5;

  // [optional] Greater than or equal to.
  optional double gte = 6;

  // [optional] Less than.
  optional double lt = 7;

  // [optional] Less than or equal to.
  optional double lte = 8;

  // [optional]
  optional NumberRangeQueryAllOfFrom from = 9;

  // [optional]
  optional NumberRangeQueryAllOfTo to = 10;

  // [optional] Include the lower bound
  optional bool include_lower = 11;

  // [optional] Include the upper bound
  optional bool include_upper = 12;

}
message NumberRangeQueryAllOfFrom {
  oneof number_range_query_all_of_from {
    double double = 1;

    string string = 2;

    NullValue null_value = 3;
  }
}
message NumberRangeQueryAllOfTo {
  oneof number_range_query_all_of_to {
    double double = 1;

    string string = 2;

    NullValue null_value = 3;
  }
}

message DateRangeQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;
  // [optional] Query name for query tagging.
  optional string x_name = 3;
  // [optional] Indicates how the range query matches values for range fields
  optional RangeRelation relation = 4;
  // [optional] Greater than.
  optional string gt = 5;
  // [optional] Greater than or equal to.
  optional string gte = 6;
  // [optional] Less than.
  optional string lt = 7;
  // [optional] Less than or equal to.
  optional string lte = 8;
  // [optional]
  optional DateRangeQueryAllOfFrom from = 9;
  // [optional]
  optional DateRangeQueryAllOfTo to = 10;
  // [optional] The date format pattern.
  optional string format = 11;
  // [optional] The time zone identifier.
  optional string time_zone = 12;
  // [optional] Include the lower bound
  optional bool include_lower = 13;
  // [optional] Include the upper bound
  optional bool include_upper = 14;
}

message DateRangeQueryAllOfFrom {
  oneof date_range_query_all_of_from {
    string string = 1;

    NullValue null_value = 2;
  }
}
message DateRangeQueryAllOfTo {
  oneof date_range_query_all_of_to {
    string string = 1;

    NullValue null_value = 2;
  }
}

enum RangeRelation {
  RANGE_RELATION_UNSPECIFIED = 0;
  RANGE_RELATION_CONTAINS = 1;
  RANGE_RELATION_INTERSECTS = 2;
  RANGE_RELATION_WITHIN = 3;
}

message RegexpQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [required] Regular expression for terms you wish to find in the provided field.
  string value = 2;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;

  // [optional] Query name for query tagging
  optional string x_name = 4;

  // [optional] If true, allows case-insensitive matching of the regular expression value with the indexed field values. Default is false (case sensitivity is determined by the field’s mapping).
  optional bool case_insensitive = 5;

  // [optional] Enables optional operators for the regular expression.
  optional string flags = 6;

  // [optional] Lucene converts a regular expression to an automaton with a number of determinized states. This parameter specifies the maximum number of automaton states the query requires. Use this parameter to prevent high resource consumption. To run complex regular expressions, you may need to increase the value of this parameter. Default is 10,000.
  optional int32 max_determinized_states = 7;

  // [optional] Determines how OpenSearch rewrites and scores multi-term queries. Valid values are constant_score, scoring_boolean, constant_score_boolean, top_terms_N, top_terms_boost_N, and top_terms_blended_freqs_N. Default is constant_score.
  optional MultiTermQueryRewrite rewrite = 8;
}

message FuzzyQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [required] Term you wish to find in the provided <field>.
  FieldValue value = 2;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;
  // [optional] Query name for query tagging.
  optional string x_name = 4;
  // [optional] The maximum number of terms to which the query can expand. Fuzzy queries "expand to" a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  optional int32 max_expansions = 5;
  // [optional] The number of leading characters that are not considered in fuzziness. Default is 0.
  optional int32 prefix_length = 6;
  // [optional] Determines how OpenSearch rewrites the query. Default is constant_score.
  optional MultiTermQueryRewrite rewrite = 7;
  // [optional] Specifies whether to allow transpositions of two adjacent characters (ab to ba) as edits. Default is true.
  optional bool transpositions = 8;
  // [optional] The number of character edits (insert, delete, substitute) needed to change one word to another when determining whether a term matched a value.
  optional Fuzziness fuzziness = 9;
}

message Fuzziness{

  oneof fuzziness{
    // AUTO: Generates an edit distance based on the length of the term. Low and high distance arguments may be optionally provided AUTO:[low],[high]. AUTO should generally be the preferred value for fuzziness.
    string string = 1;
    // 0,1,2: The maximum allowed Levenshtein Edit Distance (or number of edits)
    int32 int32 = 2;
  }

}

message FieldValue {
  optional bool bool = 1;

  optional GeneralNumber general_number = 2;

  optional string string = 3;

  optional NullValue null_value = 4;
}

message IdsQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  repeated string values = 3;

}

message IntervalsFuzzy {

  // Analyzer used to normalize the term.
  string analyzer = 1;

  Fuzziness fuzziness = 2;

  // Number of beginning characters left unchanged when creating expansions.
  int32 prefix_length = 3;

  // The term to match.
  string term = 4;

  // Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool transpositions = 5;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 6;

}

message IntervalsPrefix {

  // Analyzer used to analyze the `prefix`.
  string analyzer = 1;

  // Beginning characters of terms you wish to find in the top-level field.
  string prefix = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 3;

}

message IntervalsWildcard {

  // Analyzer used to analyze the `pattern`. Defaults to the top-level field's analyzer.
  string analyzer = 1;

  // Wildcard pattern used to find matching terms.
  string pattern = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 3;

}

message MatchAllQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;
}

message MatchBoolPrefixQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [required] Terms you wish to find in the provided field. The last term is used in a prefix query.
  string query = 2;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;
  // [optional] Query name for query tagging.
  optional string x_name = 4;
  // [optional] The analyzer used to tokenize the query string text. Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  optional string analyzer = 5;
  // [optional] The number of character edits (insert, delete, substitute) that it takes to change one word to another when determining whether a term matched a value. For example, the distance between wined and wind is 1. The default, AUTO, chooses a value based on the length of each term and is a good choice for most use cases.
  optional Fuzziness fuzziness = 6;
  // [optional] Determines how OpenSearch rewrites the query. Default is constant_score.
  optional MultiTermQueryRewrite fuzzy_rewrite = 7;
  // [optional] Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option. For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo. The default(true) is a good choice for most use cases.
  optional bool fuzzy_transpositions = 8;
  // [optional] The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  optional int32 max_expansions = 9;
  // [optional] If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match. For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  optional MinimumShouldMatch minimum_should_match = 10;
  // [optional] If the query string contains multiple search terms, whether all terms need to match (and) or only one term needs to match (or) for a document to be considered a match. Default is or.
  optional Operator operator = 11;
  // [optional] The number of leading characters that are not considered in fuzziness. Default is 0.
  optional int32 prefix_length = 12;
}

message MatchNoneQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;
}


enum ZeroTermsQuery {
  ZERO_TERMS_QUERY_UNSPECIFIED = 0;
  // zero_terms_query specifies whether to match all documents (all).
  ZERO_TERMS_QUERY_ALL = 1;
  // zero_terms_query specifies whether to match no documents (none)
  ZERO_TERMS_QUERY_NONE = 2;
}

message MatchPhrasePrefixQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [required] The query string to use for search
  string query = 2;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;
  // [optional] Query name for query tagging.
  optional string x_name = 4;
  // [optional] The analyzer used to tokenize the query string text. Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  optional string analyzer = 5;
  // [optional] The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  optional int32 max_expansions = 6;
  // [optional] Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase. For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  optional int32 slop = 7;
  // [optional] In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all. Default is none.
  optional ZeroTermsQuery zero_terms_query = 8;
}

message MatchPhraseQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;
  // [required] The query string to use for search.
  string query = 2;
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;
  // [optional] The name of the query for query tagging.
  optional string x_name = 4;
  // [optional] The analyzer used to tokenize the query string text. Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  optional string analyzer = 5;
  // [optional] Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase. For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  optional int32 slop = 6;
  // [optional] In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all. Default is none.
  optional ZeroTermsQuery zero_terms_query = 7;
}

message MultiMatchQuery {
  // [required] The query string to use for search.
  string query = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] The name of the query for query tagging.
  optional string x_name = 3;

  // [optional] The analyzer used to tokenize the query string text. Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index. For more information about index.query.default_field, see Dynamic index-level index settings.
  optional string analyzer = 4;

  // [optional] Specifies whether to create a match phrase query automatically for multi-term synonyms. For example, if you specify ba,batting average as synonyms and search for ba, OpenSearch searches for ba OR "batting average" (if this option is true) or ba OR (batting AND average) (if this option is false). Default is true.
  optional bool auto_generate_synonyms_phrase_query = 5;

  // [optional] The list of fields in which to search. If you don’t provide the fields parameter, multi_match query searches the fields specified in the index.query.default_field setting, which defaults to *.
  repeated string fields = 6;

  // [optional] Determines how OpenSearch rewrites the query. Valid values are constant_score, scoring_boolean, constant_score_boolean, top_terms_N, top_terms_boost_N, and top_terms_blended_freqs_N. If the fuzziness parameter is not 0, the query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default. Default is constant_score.
  optional string fuzzy_rewrite = 7;

  // [optional] The number of character edits (insert, delete, substitute) that it takes to change one word to another when determining whether a term matched a value.
  optional Fuzziness fuzziness = 8;

  // [optional] Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option. For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo. The default is a good choice for most use cases.
  optional bool fuzzy_transpositions = 9;

  // [optional] Setting lenient to true ignores data type mismatches between the query and the document field. For example, a query string of "8.2" could match a field of type float. Default is false.
  optional bool lenient = 10;

  // [optional] The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  optional int32 max_expansions = 11;

  // [optional] If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match. For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches. For details, see Minimum should match.

  optional MinimumShouldMatch minimum_should_match = 12;

  // [optional] If the query string contains multiple search terms, whether all terms need to match (AND) or only one term needs to match (OR) for a document to be considered a match. Valid values are: 1) OR: The string to be is interpreted as to OR be. 2) AND: The string to be is interpreted as to AND be. Default is OR.
  optional Operator operator = 13;

  // [optional] The number of leading characters that are not considered in fuzziness. Default is 0.
  optional int32 prefix_length = 14;

  // [optional] Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase. For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.” Supported for phrase and phrase_prefix query types.
  optional int32 slop = 15;

  // [optional] A factor between 0 and 1.0 that is used to give more weight to documents that match multiple query clauses. For more information, see The tie_breaker parameter`.
  optional float tie_breaker = 16;

  // [optional] The multi-match query type. Valid values are best_fields, most_fields, cross_fields, phrase, phrase_prefix, bool_prefix. Default is best_fields.
  optional TextQueryType type = 17;

  // [optional] In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all. Default is none.
  optional ZeroTermsQuery zero_terms_query = 18;
}

message FieldValueFactorScoreFunction {

  // [required] Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  // [optional] Optional factor to multiply the field value with.
  optional float factor = 2;

  // [optional] Value used if the document doesn't have that field. The modifier and factor are still applied to it as though it were read from the document.
  optional double missing = 3;

  // [optional]
  optional FieldValueFactorModifier modifier = 4;

}

enum FieldValueFactorModifier {
  FIELD_VALUE_FACTOR_MODIFIER_UNSPECIFIED = 0;
  FIELD_VALUE_FACTOR_MODIFIER_LN = 1;
  FIELD_VALUE_FACTOR_MODIFIER_LN1P = 2;
  FIELD_VALUE_FACTOR_MODIFIER_LN2P = 3;
  FIELD_VALUE_FACTOR_MODIFIER_LOG = 4;
  FIELD_VALUE_FACTOR_MODIFIER_LOG1P = 5;
  FIELD_VALUE_FACTOR_MODIFIER_LOG2P = 6;
  FIELD_VALUE_FACTOR_MODIFIER_NONE = 7;
  FIELD_VALUE_FACTOR_MODIFIER_RECIPROCAL = 8;
  FIELD_VALUE_FACTOR_MODIFIER_SQRT = 9;
  FIELD_VALUE_FACTOR_MODIFIER_SQUARE = 10;
}

message DutchAnalyzer {
  DutchAnalyzerType type = 1;

  repeated string stopwords = 2;
}
enum DutchAnalyzerType {
  DUTCH_ANALYZER_TYPE_UNSPECIFIED = 0;
  DUTCH_ANALYZER_TYPE_DUTCH = 1;
}

message FingerprintAnalyzer {
  FingerprintAnalyzerType type = 1;

  optional string version = 2;

  int32 max_output_size = 3;

  bool preserve_original = 4;

  string separator = 5;

  repeated string stopwords = 6;

  optional string stopwords_path = 7;
}
enum FingerprintAnalyzerType {
  FINGERPRINT_ANALYZER_TYPE_UNSPECIFIED = 0;
  FINGERPRINT_ANALYZER_TYPE_FINGERPRINT = 1;
}

message IcuAnalyzer {
  IcuAnalyzerType type = 1;

  IcuNormalizationType method = 2;

  IcuNormalizationMode mode = 3;
}
enum IcuAnalyzerType {
  ICU_ANALYZER_TYPE_UNSPECIFIED = 0;
  ICU_ANALYZER_TYPE_ICU_ANALYZER = 1;
}
enum IcuNormalizationMode {
  ICU_NORMALIZATION_MODE_UNSPECIFIED = 0;
  ICU_NORMALIZATION_MODE_COMPOSE = 1;
  ICU_NORMALIZATION_MODE_DECOMPOSE = 2;
}
enum IcuNormalizationType {
  ICU_NORMALIZATION_TYPE_UNSPECIFIED = 0;
  ICU_NORMALIZATION_TYPE_NFC = 1;
  ICU_NORMALIZATION_TYPE_NFKC = 2;
  ICU_NORMALIZATION_TYPE_NFKC_CF = 3;
}

message KeywordAnalyzer {
  KeywordAnalyzerType type = 1;

  optional string version = 2;
}
enum KeywordAnalyzerType {
  KEYWORD_ANALYZER_TYPE_UNSPECIFIED = 0;
  KEYWORD_ANALYZER_TYPE_KEYWORD = 1;
}


message LanguageAnalyzer {
  LanguageAnalyzerType type = 1;

  optional string version = 2;

  Language language = 3;

  repeated string stem_exclusion = 4;

  repeated string stopwords = 5;

  optional string stopwords_path = 6;
}
enum LanguageAnalyzerType {
  LANGUAGE_ANALYZER_TYPE_UNSPECIFIED = 0;
  LANGUAGE_ANALYZER_TYPE_LANGUAGE = 1;
}

enum Language {
  LANGUAGE_UNSPECIFIED = 0;
  LANGUAGE_ARABIC = 1;
  LANGUAGE_ARMENIAN = 2;
  LANGUAGE_BASQUE = 3;
  LANGUAGE_BRAZILIAN = 4;
  LANGUAGE_BULGARIAN = 5;
  LANGUAGE_CATALAN = 6;
  LANGUAGE_CHINESE = 7;
  LANGUAGE_CJK = 8;
  LANGUAGE_CZECH = 9;
  LANGUAGE_DANISH = 10;
  LANGUAGE_DUTCH = 11;
  LANGUAGE_ENGLISH = 12;
  LANGUAGE_ESTONIAN = 13;
  LANGUAGE_FINNISH = 14;
  LANGUAGE_FRENCH = 15;
  LANGUAGE_GALICIAN = 16;
  LANGUAGE_GERMAN = 17;
  LANGUAGE_GREEK = 18;
  LANGUAGE_HINDI = 19;
  LANGUAGE_HUNGARIAN = 20;
  LANGUAGE_INDONESIAN = 21;
  LANGUAGE_IRISH = 22;
  LANGUAGE_ITALIAN = 23;
  LANGUAGE_LATVIAN = 24;
  LANGUAGE_NORWEGIAN = 25;
  LANGUAGE_PERSIAN = 26;
  LANGUAGE_PORTUGUESE = 27;
  LANGUAGE_ROMANIAN = 28;
  LANGUAGE_RUSSIAN = 29;
  LANGUAGE_SORANI = 30;
  LANGUAGE_SPANISH = 31;
  LANGUAGE_SWEDISH = 32;
  LANGUAGE_THAI = 33;
  LANGUAGE_TURKISH = 34;
}

message NoriAnalyzer {
  NoriAnalyzerType type = 1;

  optional string version = 2;

  optional NoriDecompoundMode decompound_mode = 3;

  repeated string stoptags = 4;

  optional string user_dictionary = 5;
}
enum NoriAnalyzerType {
  NORI_ANALYZER_TYPE_UNSPECIFIED = 0;
  NORI_ANALYZER_TYPE_NORI = 1;
}
enum NoriDecompoundMode {
  NORI_DECOMPOUND_MODE_UNSPECIFIED = 0;
  NORI_DECOMPOUND_MODE_DISCARD = 1;
  NORI_DECOMPOUND_MODE_MIXED = 2;
  NORI_DECOMPOUND_MODE_NONE = 3;
}

message PatternAnalyzer {
  PatternAnalyzerType type = 1;

  optional string version = 2;

  optional string flags = 3;

  optional bool lowercase = 4;

  string pattern = 5;

  repeated string stopwords = 6;
}
enum PatternAnalyzerType {
  PATTERN_ANALYZER_TYPE_UNSPECIFIED = 0;
  PATTERN_ANALYZER_TYPE_PATTERN = 1;
}

message SimpleAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_SIMPLE = 1;
  }
  Type type = 1;

  string version = 2;
}

message StandardAnalyzer {
  StandardAnalyzerType type = 1;

  optional int32 max_token_length = 2;

  repeated string stopwords = 3;
}

enum StandardAnalyzerType {
  STANDARD_ANALYZER_TYPE_UNSPECIFIED = 0;
  STANDARD_ANALYZER_TYPE_STANDARD = 1;
}

message StopAnalyzer {
  StopAnalyzerType type = 1;

  optional string version = 2;

  repeated string stopwords = 3;

  optional string stopwords_path = 4;
}
enum StopAnalyzerType {
  STOP_ANALYZER_TYPE_UNSPECIFIED = 0;
  STOP_ANALYZER_TYPE_STOP = 1;
}

message WhitespaceAnalyzer {
  WhitespaceAnalyzerType type = 1;

  optional string version = 2;
}
enum WhitespaceAnalyzerType {
  WHITESPACE_ANALYZER_TYPE_UNSPECIFIED = 0;
  WHITESPACE_ANALYZER_TYPE_WHITESPACE = 1;
}

message CustomAnalyzer {
  CustomAnalyzerType type = 1;

  repeated string char_filter = 2;

  repeated string filter = 3;

  optional int32 position_increment_gap = 4;

  optional int32 position_offset_gap = 5;

  string tokenizer = 6;
}
enum CustomAnalyzerType {
  CUSTOM_ANALYZER_TYPE_UNSPECIFIED = 0;
  CUSTOM_ANALYZER_TYPE_CUSTOM = 1;
}

message Analyzer {
  oneof analyzer {
    CustomAnalyzer custom_analyzer = 1;
    FingerprintAnalyzer fingerprint_analyzer = 2;
    KeywordAnalyzer keyword_analyzer = 3;
    LanguageAnalyzer language_analyzer = 4;
    NoriAnalyzer nori_analyzer = 5;
    PatternAnalyzer pattern_analyzer = 6;
    SimpleAnalyzer simple_analyzer = 7;
    StandardAnalyzer standard_analyzer = 8;
    StopAnalyzer stop_analyzer = 9;
    WhitespaceAnalyzer whitespace_analyzer = 10;
    IcuAnalyzer icu_analyzer = 11;
    KuromojiAnalyzer kuromoji_analyzer = 12;
    SnowballAnalyzer snowball_analyzer = 13;
    DutchAnalyzer dutch_analyzer = 14;
  }
}

message KuromojiAnalyzer {
  KuromojiAnalyzerType type = 1;

  KuromojiTokenizationMode mode = 2;

  optional string user_dictionary = 3;
}
enum KuromojiAnalyzerType {
  KUROMOJI_ANALYZER_TYPE_UNSPECIFIED = 0;
  KUROMOJI_ANALYZER_TYPE_KUROMOJI = 1;
}
enum KuromojiTokenizationMode {
  KUROMOJI_TOKENIZATION_MODE_UNSPECIFIED = 0;
  KUROMOJI_TOKENIZATION_MODE_EXTENDED = 1;
  KUROMOJI_TOKENIZATION_MODE_NORMAL = 2;
  KUROMOJI_TOKENIZATION_MODE_SEARCH = 3;
}

message SnowballAnalyzer {
  SnowballAnalyzerType type = 1;

  optional string version = 2;

  SnowballLanguage language = 3;

  repeated string stopwords = 4;
}
enum SnowballAnalyzerType {
  SNOWBALL_ANALYZER_TYPE_UNSPECIFIED = 0;
  SNOWBALL_ANALYZER_TYPE_SNOWBALL = 1;
}

enum SnowballLanguage {
  SNOWBALL_LANGUAGE_UNSPECIFIED = 0;
  SNOWBALL_LANGUAGE_ARMENIAN = 1;
  SNOWBALL_LANGUAGE_BASQUE = 2;
  SNOWBALL_LANGUAGE_CATALAN = 3;
  SNOWBALL_LANGUAGE_DANISH = 4;
  SNOWBALL_LANGUAGE_DUTCH = 5;
  SNOWBALL_LANGUAGE_ENGLISH = 6;
  SNOWBALL_LANGUAGE_FINNISH = 7;
  SNOWBALL_LANGUAGE_FRENCH = 8;
  SNOWBALL_LANGUAGE_GERMAN = 9;
  SNOWBALL_LANGUAGE_GERMAN2 = 10;
  SNOWBALL_LANGUAGE_HUNGARIAN = 11;
  SNOWBALL_LANGUAGE_ITALIAN = 12;
  SNOWBALL_LANGUAGE_KP = 13;
  SNOWBALL_LANGUAGE_LOVINS = 14;
  SNOWBALL_LANGUAGE_NORWEGIAN = 15;
  SNOWBALL_LANGUAGE_PORTER = 16;
  SNOWBALL_LANGUAGE_PORTUGUESE = 17;
  SNOWBALL_LANGUAGE_ROMANIAN = 18;
  SNOWBALL_LANGUAGE_RUSSIAN = 19;
  SNOWBALL_LANGUAGE_SPANISH = 20;
  SNOWBALL_LANGUAGE_SWEDISH = 21;
  SNOWBALL_LANGUAGE_TURKISH = 22;
}

message Error {
  oneof version {
    OpenSearchExceptionV1 v1 = 1;
  }
}


message OpenSearchExceptionV1 {
  string type = 1;
  string reason = 2;
  repeated .google.protobuf.Struct root_cause = 3;

  .google.protobuf.Struct caused_by = 4;
  string stack_trace = 5;
  .google.protobuf.Struct suppressed = 6;

  .google.protobuf.Struct additional_details = 7;
}

message InlineGet {

  .google.protobuf.Struct fields = 1;

  bool found = 2;

  int64 x_seq_no = 3;

  int64 x_primary_term = 4;

  repeated string x_routing = 5;

  oneof inline_get_source {

    // struct_source field to be returned upon explicit request by user
    .google.protobuf.Struct struct_source = 6;

    // Use bytes for better latency/performance, as it reduces payload size over the wire
    bytes x_source = 7;

  }
}
