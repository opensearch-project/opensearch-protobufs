/**
This is generated from the spec. DO NOT manually modify.
*/
syntax = "proto3";

option java_multiple_files = true;
option java_package = "org.opensearch.protobufs";
option java_outer_classname = "CommonProto";
option go_package = "github.com/opensearch-project/opensearch-protobufs/go/opensearchpb";

import "google/protobuf/struct.proto";

message WaitForActiveShards {

  oneof wait_for_active_shards {
    int32 int32_value = 1;
    WaitForActiveShardOptions wait_for_active_shard_options = 2;
  }
}
enum WaitForActiveShardOptions {
  WAIT_FOR_ACTIVE_SHARD_OPTIONS_UNSPECIFIED = 0;
  WAIT_FOR_ACTIVE_SHARD_OPTIONS_ALL = 1;
  WAIT_FOR_ACTIVE_SHARD_OPTIONS_NULL = 2;
}

message Script {
  oneof script {
    // Defines an inline script to execute as part of a query.
    InlineScript inline = 1;
    // References a stored script by its ID for use in a query.
    StoredScriptId stored = 2;
  }
}

message InlineScript {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;

  // [optional]
  // The script's language. Default is painless.
  ScriptLanguage lang = 2;

  map<string, string> options = 3;

  // [required]
  // The script source.
  string source = 4;
}

message ScriptLanguage {
  oneof script_language {
    BuiltinScriptLanguage builtin = 1;

    string custom = 2;
  }
}

enum BuiltinScriptLanguage {
  BUILTIN_SCRIPT_LANGUAGE_UNSPECIFIED = 0;
  BUILTIN_SCRIPT_LANGUAGE_EXPRESSION = 1;
  BUILTIN_SCRIPT_LANGUAGE_JAVA = 2;
  BUILTIN_SCRIPT_LANGUAGE_MUSTACHE = 3;
  BUILTIN_SCRIPT_LANGUAGE_PAINLESS = 4;
}

enum ExpandWildcard {
  EXPAND_WILDCARD_UNSPECIFIED = 0;
  EXPAND_WILDCARD_ALL = 1;
  EXPAND_WILDCARD_CLOSED = 2;
  EXPAND_WILDCARD_HIDDEN = 3;
  EXPAND_WILDCARD_NONE = 4;
  EXPAND_WILDCARD_OPEN = 5;
}

enum SearchType {
  SEARCH_TYPE_UNSPECIFIED = 0;
  SEARCH_TYPE_DFS_QUERY_THEN_FETCH = 1;
  SEARCH_TYPE_QUERY_THEN_FETCH = 2;
}

enum SuggestMode {
  SUGGEST_MODE_UNSPECIFIED = 0;
  // Use suggestions based on the provided terms
  SUGGEST_MODE_ALWAYS = 1;
  // Use suggestions for terms not in the index
  SUGGEST_MODE_MISSING = 2;
  // Use suggestions that have more occurrences
  SUGGEST_MODE_POPULAR = 3;
}

message StoredScriptId {
  // [optional]
  // The parameters that can be passed to the script.
  ObjectMap params = 1;
  // [required]
  // The ID of a stored script previously created using the Create Stored Script API.
  string id = 2;
}

message ObjectMap {
  map<string, Value> fields = 1;

  message Value {
    oneof value {
      NullValue null_value = 1;
      int32 int32 = 2;
      int64 int64 = 3;
      float float = 4;
      double double = 5;
      string string = 6;
      bool bool = 7;
      ObjectMap object_map = 8;
      ListValue list_value = 9;
    }
  }

  // `ListValue` is a wrapper around a repeated field of values.
  // The JSON representation for `ListValue` is JSON array.
  message ListValue {
    // Repeated field of dynamically typed values.
    repeated Value value = 1;
  }
}

enum NullValue {
  NULL_VALUE_UNSPECIFIED = 0;
  NULL_VALUE_NULL = 1;
}

// [optional] Controls how document source fields are returned in the response.
// - If not set, source is returned as bytes (default, recommended for better performance)
// - If set to SOURCE_TYPE_STRUCT: source is returned as a structured protobuf message
enum SourceType {
  SOURCE_TYPE_UNSPECIFIED = 0;
  SOURCE_TYPE_STRUCT = 1;
}

message GeoLocation {
  oneof geo_location {
    // The location specified using latitude and longitude coordinates.
    LatLonGeoLocation latlon = 1;

    // The location specified using a geohash value.
    GeoHashLocation geohash = 2;

    DoubleArray double_array = 3;

    // The location specified as a string in `lat,lon` or WKT format.
    string text = 4;
  }
}

message DoubleArray {
  // The location specified as an array of `[longitude, latitude]`.
  repeated double double_array = 1;
}

message NumberArray {

  repeated double number_array = 1;

}

message LatLonGeoLocation {
  // [required] Latitude
  double lat = 1;

  // [required] Longitude
  double lon = 2;

}

message GeoHashLocation {
  // [required]
  string geohash = 1;

}

message GeneralNumber {
  oneof value{
    int32 int32_value = 1;
    int64 int64_value = 2;
    float float_value = 3;
    double double_value = 4;
  }
}

message SourceConfigParam {

  oneof source_config_param {
    // `true` or `false` to return the `_source` field or not
    bool bool_value = 1;
    // list of fields to be retrieved from `_source`
    StringArray string_array = 2;
  }

}

message StringArray{
  repeated string string_array = 1;
}

message StringOrStringArray {
  oneof string_or_string_array{
    string string_value = 1;
    StringArray string_array = 2;
  }
}


message Id {
  oneof id {
    NullValue null_value = 1;
    string string = 2;
  }
}


message SourceConfig {

  oneof source_config{
    // [optional] if the source_config is bool value. true: The entire document source is returned. false: The document source is not returned.
    bool fetch = 1;

    // [optional] source_filter type containing a list of source fields to include or exclude.
    SourceFilter filter = 2;
  }

}

message RuntimeField {

  // For type `lookup`
  repeated RuntimeFieldFetchFields fetch_fields = 1;

  // A custom format for `date` type runtime fields.
  string format = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string input_field = 3;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string target_field = 4;

  string target_index = 5;

  Script script = 6;

  enum RuntimeFieldType {
    RUNTIME_FIELD_TYPE_UNSPECIFIED = 0;
    RUNTIME_FIELD_TYPE_BOOLEAN = 1;
    RUNTIME_FIELD_TYPE_DATE = 2;
    RUNTIME_FIELD_TYPE_DOUBLE = 3;
    RUNTIME_FIELD_TYPE_GEO_POINT = 4;
    RUNTIME_FIELD_TYPE_IP = 5;
    RUNTIME_FIELD_TYPE_KEYWORD = 6;
    RUNTIME_FIELD_TYPE_LONG = 7;
    RUNTIME_FIELD_TYPE_LOOKUP = 8;
  }

  RuntimeFieldType type = 7;

}

message RuntimeFieldFetchFields {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  string format = 2;

}

message SourceFilter {
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to exclude from the response.
  repeated string excludes = 1;
  // [optional] Wildcard (*) patterns are supported as array elements to specify source fields to return.
  repeated string includes = 2;
}

message ErrorCause {

  // [required] The type of error
  string type = 1;

  // A human-readable explanation of the error, in english
  optional string reason = 2;

  // The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.
  optional string stack_trace = 3;

  optional ErrorCause caused_by = 4;

  repeated ErrorCause root_cause = 5;

  repeated ErrorCause suppressed = 6;

  optional string index = 7;

  optional string shard = 8;

  optional string index_uuid = 9;

  // [optional] The spec actually does not have a field named 'metadata'. This should have adaptor_unnest.
  map<string, ObjectMap.Value> metadata = 10;

  // [optional]
  map<string, StringOrStringArray> header = 11;
}
message ShardStatistics {
  // [required] Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having failed+successful less than total is thus an indication that some of the shards were not allocated.
  int32 failed = 1;

  // [required] Number of shards that executed the request successfully.
  int32 successful = 2;

  // [required] Total number of shards that require querying, including unallocated shards.
  int32 total = 3;

  // [optional] An array of any shard-specific failures that occurred during the search operation.
  repeated ShardFailure failures = 4;

  // [optional] Number of shards that skipped the request because a lightweight check helped realize that no documents could possibly match on this shard. This typically happens when a search request includes a range filter and the shard only has values that fall outside of that range.
  int32 skipped = 5;

}

message ShardInfo {
  // [required] Number of shards that failed to execute the request. Note that shards that are not allocated will be considered neither successful nor failed. Having failed+successful less than total is thus an indication that some of the shards were not allocated.
  int32 failed = 1;

  // [required] Number of shards that executed the request successfully.
  int32 successful = 2;

  // [required] Total number of shards that require querying, including unallocated shards.
  int32 total = 3;

  // [optional] An array of any shard-specific failures that occurred during the search operation.
  repeated ShardFailure failures = 4;

}

message ShardFailure {

  // [optional] Name of the index in which the shard failure occurred.
  optional string index = 1;

  // [optional] ID of the node where the shard is located.
  optional string node = 2;

  // [required] Provides details about the error that caused the shard failure.
  ErrorCause reason = 3;

  // [required] The shard number where the failure occurred.
  int32 shard = 4;

  // [optional] Error status.
  optional string status = 5;

  // [required]
  bool primary = 6;

}

message ShardSearchFailure {

  // [optional] Name of the index in which the shard failure occurred.
  optional string index = 1;

  // [optional] ID of the node where the shard is located.
  optional string node = 2;

  // [required] Provides details about the error that caused the shard failure.
  ErrorCause reason = 3;

  // [required] The shard number where the failure occurred.
  int32 shard = 4;

  // [optional] Error status.
  optional string status = 5;
}

message QueryContainer {
  oneof query_container{
    // A Boolean (bool) query can combine several query clauses into one advanced query. The clauses are combined with Boolean logic to find matching documents returned in the results.
    BoolQuery bool = 1;

    // A boosting query returns documents that match a positive query. Among those documents, the ones that also match the negative query are scored lower in relevance (their relevance score is multiplied by the negative boosting factor).
    BoostingQuery boosting = 2;

    // A constant_score query wraps a filter query and assigns all documents in the results a relevance score equal to the value of the boost parameter.
    ConstantScoreQuery constant_score = 3;

    // A disjunction max (dis_max) query returns any document that matches one or more query clauses. For documents that match multiple query clauses, the relevance score is set to the highest relevance score from all matching query clauses.
    DisMaxQuery dis_max = 4;

    // Use a function_score query if you need to alter the relevance scores of documents returned in the results. A function_score query defines a query and one or more functions that can be applied to all results or subsets of the results to recalculate their relevance scores.
    FunctionScoreQuery function_score = 5;

    // Use the exists query to search for documents that contain a specific field.
    ExistsQuery exists = 6;

    // Fuzzy query is to searches for documents containing terms that are similar to the search term within the maximum allowed Damerau–Levenshtein distance. The Damerau–Levenshtein distance measures the number of one-character changes needed to change one term to another term.
    FuzzyQuery fuzzy = 7;

    // Use the ids query to search for documents with one or more specific document ID values in the _id field. For example, the following query requests documents with the IDs 34229 and 91296.
    IdsQuery ids = 8;

    // Prefix query is to search for terms that begin with a specific prefix.
    PrefixQuery prefix = 9;

    // Returns documents that contain terms within a provided range.
    RangeQuery range = 10;

    // Returns documents that contain terms matching a regular expression.
    RegexpQuery regexp = 11;

    // Term query is to search for an exact term in a field. The term query does not analyze the search term. The term query only searches for the exact term you provide.
    TermQuery term = 12;

    // Terms query field is to search for documents containing one or more terms in a specific field. Use the terms query to search for multiple terms in the same field.
    TermsQuery terms = 13;

    // terms set query is to search for documents that match a minimum number of exact terms in a specified field. A terms_set query is similar to a terms query, except that you can specify the minimum number of matching terms that are required in order to return a document. You can specify this number either in a field in the index or with a script.
    TermsSetQuery terms_set = 14;

    // Returns documents that contain terms matching a wildcard pattern.
    WildcardQuery wildcard = 15;

    // Use the match query for full-text search on a specific document field. If you run a match query on a text field, the match query analyzes the provided search string and returns documents that match any of the string's terms. If you run a match query on an exact-value field, it returns documents that match the exact value. The preferred way to search exact-value fields is to use a filter because, unlike a query, a filter is cached.
    MatchQueryTypeless match = 16;

    // The match_bool_prefix query analyzes the provided search string and creates a Boolean query from the string's terms. It uses every term except the last term as a whole word for matching. The last term is used as a prefix. The match_bool_prefix query returns documents that contain either the whole-word terms or terms that start with the prefix term, in any order.
    MatchBoolPrefixQuery match_bool_prefix = 17;

    // Use the match_phrase query to match documents that contain an exact phrase in a specified order. You can add flexibility to phrase matching by providing the slop parameter.
    MatchPhraseQuery match_phrase = 18;

    // Use the match_phrase_prefix query to specify a phrase to match in order. The documents that contain the phrase you specify will be returned. The last partial term in the phrase is interpreted as a prefix, so any documents that contain phrases that begin with the phrase and prefix of the last term will be returned.
    MatchPhrasePrefixQuery match_phrase_prefix = 19;

    // A multi-match operation functions similarly to the match operation. You can use a multi_match query to search multiple fields.
    MultiMatchQuery multi_match = 20;

    // A query_string query parses the query string based on the query string syntax. It provides for creating powerful yet concise queries that can incorporate wildcards and search multiple fields.
    QueryStringQuery query_string = 21;

    // Use the simple_query_string type to specify multiple arguments delineated by regular expressions directly in the query string. Simple query string has a less strict syntax than query string because it discards any invalid portions of the string and does not return errors for invalid syntax.
    SimpleQueryStringQuery simple_query_string = 22;

    // Returns documents based on the order and proximity of matching terms.
    IntervalsQuery intervals = 23;

    // Knn query is to search for the k-nearest neighbors to a query point across an index of vectors. To determine the neighbors, you can specify the space (the distance function) you want to use to measure the distance between points.
    KnnQuery knn = 24;

    // The match all query returns all documents. This query can be useful in testing large document sets if you need to return the entire set.
    MatchAllQuery match_all = 25;

    // This is the inverse of the match_all query, which matches no documents.
    MatchNoneQuery match_none = 26;

    // Use a script_score query to customize the score calculation by using a script. For an expensive scoring function, you can use a script_score query to calculate the score only for the returned documents that have been filtered.
    ScriptScoreQuery script_score = 27;

    // The nested query acts as a wrapper for other queries to search nested fields. The nested field objects are searched as though they were indexed as separate documents. If an object matches the search, the nested query returns the parent document at the root level.
    NestedQuery nested = 28;

    // A geodistance query returns documents with geopoints that are within a specified distance from the provided geopoint. A document with multiple geopoints matches the query if at least one geopoint matches the query.
    GeoDistanceQuery geo_distance = 29;

    // To search for documents that contain geopoint fields, use a geo-bounding box query. The geo-bounding box query returns documents whose geopoints are within the bounding box specified in the query. A document with multiple geopoints matches the query if at least one geopoint is within the bounding box.
    GeoBoundingBoxQuery geo_bounding_box = 30;
  }
}

message GeoBoundingBoxQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;
  // [optional] The name of the filter.
  optional string x_name = 2;
  // [optional]
  optional GeoExecution type = 3;
  // [optional] The validation method. Valid values are IGNORE_MALFORMED (accept geopoints with invalid coordinates), COERCE (try to coerce coordinates to valid values), and STRICT (return an error when coordinates are invalid). Default is STRICT.
  optional GeoValidationMethod validation_method = 4;
  // [optional] Specifies whether to ignore an unmapped field. If set to true, the query does not return any documents that have an unmapped field. If set to false, an exception is thrown when the field is unmapped. Default is false.
  optional bool ignore_unmapped = 5;
  // [optional]
  map<string, GeoBounds> bounding_box = 6;
}

message GeoBounds {
  oneof geo_bounds {
    // The bounds specified using coordinate values.
    CoordsGeoBounds coords = 1;

    // The bounds specified using upper-left and lower-right points.
    TopLeftBottomRightGeoBounds tlbr = 2;

    // The bounds specified using upper-right and lower-left points.
    TopRightBottomLeftGeoBounds trbl = 3;

    // The bounds specified using WKT format.
    WktGeoBounds wkt = 4;
  }
}

message WktGeoBounds {
  // [required] The WKT string representation of the geographical bounds.
  string wkt = 1;
}

message CoordsGeoBounds {
  // [required] The top boundary latitude.
  double top = 1;

  // [required] The bottom boundary latitude.
  double bottom = 2;

  // [required] The left boundary longitude.
  double left = 3;

  // [required] The right boundary longitude.
  double right = 4;
}

message TopLeftBottomRightGeoBounds {
  // [required] The upper-left corner coordinates.
  GeoLocation top_left = 1;

  // [required] The lower-right corner coordinates.
  GeoLocation bottom_right = 2;
}

message TopRightBottomLeftGeoBounds {
  // [required] The upper-right corner coordinates.
  GeoLocation top_right = 1;

  // [required] The lower-left corner coordinates.
  GeoLocation bottom_left = 2;
}

enum GeoExecution {
  GEO_EXECUTION_UNSPECIFIED = 0;
  GEO_EXECUTION_INDEXED = 1;
  GEO_EXECUTION_MEMORY = 2;
}

message GeoDistanceQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;
  // [optional] The name of the filter.
  optional string x_name = 2;
  // [required] The distance within which to match the points. This distance is the radius of a circle centered at the specified point. For supported distance units, see Distance units.
  string distance = 3;
  // [optional] Specifies how to calculate the distance. Valid values are arc or plane (faster but inaccurate for long distances or points close to the poles).
  optional GeoDistanceType distance_type = 4;
  // [optional] The validation method. Valid values are IGNORE_MALFORMED (accept geopoints with invalid coordinates), COERCE (try to coerce coordinates to valid values), and STRICT (return an error when coordinates are invalid). Default is STRICT.
  optional GeoValidationMethod validation_method = 5;
  // [optional] Set to `true` to ignore an unmapped field and not match any documents for this query. Set to `false` to throw an exception if the field is not mapped.
  optional bool ignore_unmapped = 6;
  // [optional]
  map<string, GeoLocation> location = 7;
}

message TermsQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // [optional] Specifies the types of values used for filtering. Valid values are `default` and `bitmap`. Default is `default`.
  optional TermsQueryValueType value_type = 3;

  // [optional]
  map<string, TermsQueryField> terms = 4;
}

message NestedQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // Set to `true` to ignore an unmapped field and not match any documents for this query. Set to `false` to throw an exception if the field is not mapped.
  bool ignore_unmapped = 3;

  InnerHits inner_hits = 4;

  // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  string path = 5;

  QueryContainer query = 6;

  enum ChildScoreMode {
    CHILD_SCORE_MODE_UNSPECIFIED = 0;
    CHILD_SCORE_MODE_AVG = 1;
    CHILD_SCORE_MODE_MAX = 2;
    CHILD_SCORE_MODE_MIN = 3;
    CHILD_SCORE_MODE_NONE = 4;
    CHILD_SCORE_MODE_SUM = 5;
  }
  ChildScoreMode score_mode = 7;

}

message InnerHits {

  // [optional] The name to be used for the particular inner hit definition in the response. Useful when multiple inner hits have been defined in a single search request.
  optional string name = 1;

  // [optional] The maximum number of hits to return per `inner_hits`.
  optional int32 size = 2;

  // [optional] Inner hit starting document offset.
  optional int32 from = 3;

  // [optional] The collapse parameter groups search results by a particular field value. This returns only the top document within each group, which helps reduce redundancy by eliminating duplicates.
  optional FieldCollapse collapse = 4;

  // [optional] The fields that OpenSearch should return using their docvalue forms. Specify a format to return results in a certain format, such as date and time.
  repeated FieldAndFormat docvalue_fields = 5;

  // [optional] Whether to return details about how OpenSearch computed the document's score. Default is false.
  optional bool explain = 6;

  // [optional] Highlighting emphasizes the search term(s) in the results so you can emphasize the query matches.
  optional Highlight highlight = 7;

  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  optional bool ignore_unmapped = 8;

  // [optional] The script_fields parameter allows you to include custom fields whose values are computed using scripts in your search results. This can be useful for calculating values dynamically based on the document data. You can also retrieve derived fields by using a similar approach.
  map<string, ScriptField> script_fields = 9;

  // [optional] Whether to return sequence number and primary term of the last operation of each document hit.
  optional bool seq_no_primary_term = 10;

  // [optional] Retrieve selected fields from a search
  repeated string fields = 11;

  // [optional] How the inner hits should be sorted per inner_hits. By default the hits are sorted by the score.
  repeated SortOptions sort = 12;

  // [optional] Select what fields of the source are returned
  optional SourceConfig x_source = 13;

  // [optional] A list of stored fields to return as part of a hit. If no fields are specified, no stored fields are included in the response. If this option is specified, the _source parameter defaults to false. You can pass _source: true to return both source fields and stored fields in the search response.
  repeated string stored_fields = 14;

  // [optional] Whether to return document scores. Default is false.
  optional bool track_scores = 15;

  // [optional] Whether to include the document version as a match.
  optional bool version = 16;

}

message ScriptField {
  Script script = 1;
  optional bool ignore_failure = 2;
}

message HighlighterType {
  oneof highlighter_type {
    BuiltinHighlighterType builtin = 1;

    string custom = 2;
  }
}

enum BuiltinHighlighterType {
  BUILTIN_HIGHLIGHTER_TYPE_UNSPECIFIED = 0;
  BUILTIN_HIGHLIGHTER_TYPE_PLAIN = 1;
  BUILTIN_HIGHLIGHTER_TYPE_FVH = 2;
  BUILTIN_HIGHLIGHTER_TYPE_UNIFIED = 3;
}

enum BoundaryScanner {
  BOUNDARY_SCANNER_UNSPECIFIED = 0;
  BOUNDARY_SCANNER_CHARS = 1;
  BOUNDARY_SCANNER_SENTENCE = 2;
  BOUNDARY_SCANNER_WORD = 3;
}

enum HighlighterFragmenter {
  HIGHLIGHTER_FRAGMENTER_UNSPECIFIED = 0;
  HIGHLIGHTER_FRAGMENTER_SIMPLE = 1;
  HIGHLIGHTER_FRAGMENTER_SPAN = 2;
}

enum HighlighterOrder {
  HIGHLIGHTER_ORDER_UNSPECIFIED = 0;
  HIGHLIGHTER_ORDER_SCORE = 1;
}

enum HighlighterTagsSchema {
  HIGHLIGHTER_TAGS_SCHEMA_UNSPECIFIED = 0;
  HIGHLIGHTER_TAGS_SCHEMA_STYLED = 1;
}

enum HighlighterEncoder {
  HIGHLIGHTER_ENCODER_UNSPECIFIED = 0;
  // No encoding
  HIGHLIGHTER_ENCODER_DEFAULT = 1;
  // First escape the HTML text and then insert the highlighting tags
  HIGHLIGHTER_ENCODER_HTML = 2;
}

message Highlight {
  // [optional] Specifies the highlighter to use. Default is unified.
  optional HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  optional string boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  optional int32 boundary_max_scan = 3;

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  optional BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  optional string boundary_scanner_locale = 5;

  // [x-deprecated]
  optional bool force_source = 6;

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  optional HighlighterFragmenter fragmenter = 7;
  // [optional]
  optional int32 fragment_offset = 8;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  optional int32 fragment_size = 9;

  // [optional]
  optional bool highlight_filter = 10;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  optional QueryContainer highlight_query = 11;

  // [optional]
  optional int32 max_fragment_length = 12;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  optional int32 max_analyzed_offset = 13;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  optional int32 no_match_size = 14;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  optional int32 number_of_fragments = 15;

  optional ObjectMap options = 16;

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  optional HighlighterOrder order = 17;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  optional int32 phrase_limit = 18;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 19;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 20;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  optional bool require_field_match = 21;

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  optional HighlighterTagsSchema tags_schema = 22;

  // [optional] Specifies whether the highlighted fragment should be HTML encoded before it is returned.
  optional HighlighterEncoder encoder = 23;

  // [required] Specifies the fields to search for text to be highlighted. Supports wildcard expressions. If you use wildcards, only text and keyword fields are highlighted. For example, you can set fields to my_field* to include all text and keyword fields that start with the prefix my_field.
  map<string, HighlightField> fields = 24;

}

message HighlightField {
  // [optional] Specifies the highlighter to use. Default is unified.
  optional HighlighterType type = 1;

  // [optional] All boundary characters combined in a string. Default is ".,!? \t\n".
  optional string boundary_chars = 2;

  // [optional] Controls how far to scan for boundary characters when the boundary_scanner parameter for the fvh highlighter is set to chars. Default is 20.
  optional int32 boundary_max_scan = 3;

  // [optional] Specifies whether to split the highlighted fragments into sentences, words, or characters.
  optional BoundaryScanner boundary_scanner = 4;

  // [optional] Provides a locale for the boundary_scanner. Valid values are language tags (for example, "en-US"). Default is Locale.ROOT.
  optional string boundary_scanner_locale = 5;

  // [x-deprecated]
  bool force_source = 6;

  // [optional] Specifies how to split text into highlighted fragments. Valid only for the plain highlighter. Default HIGHLIGHTER_FRAGMENTER_SPAN.
  optional HighlighterFragmenter fragmenter = 7;

  // [optional] The size of a highlighted fragment, specified as the number of characters. If number_of_fragments is set to 0, fragment_size is ignored. Default is 100.
  optional int32 fragment_size = 8;

  optional bool highlight_filter = 9;

  // [optional] Specifies that matches for a query other than the search query should be highlighted. The highlight_query option is useful when you use a faster query to get document matches and a slower query (for example, rescore_query) to refine the results. We recommend to include the search query as part of the highlight_query.
  optional QueryContainer highlight_query = 10;

  optional int32 max_fragment_length = 11;

  // [optional] If set to a non-negative value, highlighting stops at this defined maximum limit. The rest of the text is not processed, thus not highlighted and no error is returned The `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when it's set to lower value than the query setting.
  optional int32 max_analyzed_offset = 12;

  // [optional] Specifies the number of characters, starting from the beginning of the field, to return if there are no matching fragments to highlight. Default is 0.
  optional int32 no_match_size = 13;

  // [optional] The maximum number of returned fragments. If number_of_fragments is set to 0, OpenSearch returns the highlighted contents of the entire field. Default is 5.
  optional int32 number_of_fragments = 14;
  // [optional]
  optional ObjectMap options = 15;

  // [optional] The sort order for the highlighted fragments. Each highlighter has a different algorithm for calculating relevance scores. Default is none.
  optional HighlighterOrder order = 16;

  // [optional] The number of matching phrases in a document that are considered. Limits the number of phrases to analyze by the fvh highlighter to avoid consuming a lot of memory. If matched_fields are used, phrase_limit specifies the number of phrases for each matched field. A higher phrase_limit leads to increased query time and more memory consumption. Valid only for the fvh highlighter. Default is 256.
  optional int32 phrase_limit = 17;

  // [optional] Specifies the HTML end tags for the highlighted text as an array of strings.
  repeated string post_tags = 18;

  // [optional] Specifies the HTML start tags for the highlighted text as an array of strings.
  repeated string pre_tags = 19;

  // [optional] Specifies whether to highlight only fields that contain a search query match. Default is true. To highlight all fields, set this option to false.
  optional bool require_field_match = 20;
  // [optional]
  optional HighlighterTagsSchema tags_schema = 21;

  // [optional] If you set this option to styled, OpenSearch uses the built-in tag schema. In this schema, the pre_tags are <em class="hlt1">, <em class="hlt2">, <em class="hlt3">, <em class="hlt4">, <em class="hlt5">, <em class="hlt6">, <em class="hlt7">, <em class="hlt8">, <em class="hlt9">, and <em class="hlt10">, and the post_tags is </em>.
  optional int32 fragment_offset = 22;

  // [optional] Combines matches from different fields to highlight one field. The most common use case for this functionality is highlighting text that is analyzed in different ways and kept in multi-fields. All fields in the matched_fields list must have the term_vector field set to with_positions_offsets. The field in which the matches are combined is the only loaded field, so it is beneficial to set its store option to yes. Valid only for the fvh highlighter.
  repeated string matched_fields = 23;
  // [optional]
  optional Analyzer analyzer = 24;

}

message FieldWithOrderMap {
  // [required] Map of fields and their corresponding sort order.
  map<string, ScoreSort> field_with_order_map = 1;
}

message SortOptions {
  oneof sort_options {
    // Sort by document score.
    bool sort_options_score = 1;

    // Sort by document index order.
    bool sort_options_doc = 2;

    // Sort by field name.
    string string = 3;

    SortOptionsOneOf sort_options_one_of = 4;

    // Sort by field options.
    FieldSort field_sort = 5;
  }
}

message FieldSort {
  // The value to use when the field is missing.
  optional FieldValue missing = 1;

  // The mode for sorting on array fields.
  optional SortMode mode = 2;

  // The nested path sort options.
  optional NestedSortValue nested = 3;

  // The sort order direction.
  optional SortOrder order = 4;

  // The type to use for unmapped fields.
  optional FieldType unmapped_type = 5;

  // The numeric type to use for sorting.
  optional FieldSortNumericType numeric_type = 6;

  // The format to use for the sort values.
  optional string format = 7;

  optional string field = 8;
}

enum FieldSortNumericType {
  FIELD_SORT_NUMERIC_TYPE_UNSPECIFIED = 0;
  FIELD_SORT_NUMERIC_TYPE_DATE = 1;
  FIELD_SORT_NUMERIC_TYPE_DATE_NANOS = 2;
  FIELD_SORT_NUMERIC_TYPE_DOUBLE = 3;
  FIELD_SORT_NUMERIC_TYPE_LONG = 4;
}

enum FieldType {
  FIELD_TYPE_UNSPECIFIED = 0;
  FIELD_TYPE_AGGREGATE_METRIC_DOUBLE = 1;
  FIELD_TYPE_ALIAS = 2;
  FIELD_TYPE_BINARY = 3;
  FIELD_TYPE_BOOLEAN = 4;
  FIELD_TYPE_BYTE = 5;
  FIELD_TYPE_COMPLETION = 6;
  FIELD_TYPE_CONSTANT_KEYWORD = 7;
  FIELD_TYPE_DATE = 8;
  FIELD_TYPE_DATE_NANOS = 9;
  FIELD_TYPE_DATE_RANGE = 10;
  FIELD_TYPE_DOUBLE = 11;
  FIELD_TYPE_DOUBLE_RANGE = 12;
  FIELD_TYPE_FLAT_OBJECT = 13;
  FIELD_TYPE_FLOAT = 14;
  FIELD_TYPE_FLOAT_RANGE = 15;
  FIELD_TYPE_GEO_POINT = 16;
  FIELD_TYPE_GEO_SHAPE = 17;
  FIELD_TYPE_HALF_FLOAT = 18;
  FIELD_TYPE_HISTOGRAM = 19;
  FIELD_TYPE_ICU_COLLATION_KEYWORD = 20;
  FIELD_TYPE_INTEGER = 21;
  FIELD_TYPE_INTEGER_RANGE = 22;
  FIELD_TYPE_IP = 23;
  FIELD_TYPE_IP_RANGE = 24;
  FIELD_TYPE_JOIN = 25;
  FIELD_TYPE_KEYWORD = 26;
  FIELD_TYPE_KNN_VECTOR = 27;
  FIELD_TYPE_LONG = 28;
  FIELD_TYPE_LONG_RANGE = 29;
  FIELD_TYPE_MATCH_ONLY_TEXT = 30;
  FIELD_TYPE_MURMUR3 = 31;
  FIELD_TYPE_NESTED = 32;
  FIELD_TYPE_OBJECT = 33;
  FIELD_TYPE_PERCOLATOR = 34;
  FIELD_TYPE_RANK_FEATURE = 35;
  FIELD_TYPE_RANK_FEATURES = 36;
  FIELD_TYPE_SCALED_FLOAT = 37;
  FIELD_TYPE_SEARCH_AS_YOU_TYPE = 38;
  FIELD_TYPE_SHORT = 39;
  FIELD_TYPE_TEXT = 40;
  FIELD_TYPE_TOKEN_COUNT = 41;
  FIELD_TYPE_UNSIGNED_LONG = 42;
  FIELD_TYPE_VERSION = 43;
  FIELD_TYPE_WILDCARD = 44;
  FIELD_TYPE_XY_POINT = 45;
  FIELD_TYPE_XY_SHAPE = 46;
}

message SortOptionsOneOf {
  // [optional]
  optional ScoreSort x_score = 1;
  // [optional]
  optional ScoreSort x_doc = 2;
  // [optional]
  optional GeoDistanceSort x_geo_distance = 3;
  // [optional]
  optional ScriptSort x_script = 4;
}

message ScoreSort {
  // Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 1;
}

enum SortOrder {
  SORT_ORDER_UNSPECIFIED = 0;
  // Sort in ascending order.
  SORT_ORDER_ASC = 1;
  // Sort in descending order
  SORT_ORDER_DESC = 2;
}

enum SortMode {
  SORT_MODE_UNSPECIFIED = 0;
  SORT_MODE_AVG = 1;
  SORT_MODE_MAX = 2;
  SORT_MODE_MEDIAN = 3;
  SORT_MODE_MIN = 4;
  SORT_MODE_SUM = 5;
}

enum GeoDistanceType {
  GEO_DISTANCE_TYPE_UNSPECIFIED = 0;
  GEO_DISTANCE_TYPE_ARC = 1;
  GEO_DISTANCE_TYPE_PLANE = 2;
}

message GeoDistanceSort {

  // [optional] Specifies how to handle a field with several geopoints.
  optional SortMode mode = 1;

  // [optional] Specifies the method of computing the distance.
  optional GeoDistanceType distance_type = 2;

  // [optional] Specifies how to treat an unmapped field. Set ignore_unmapped to true to ignore unmapped fields. Default is false
  optional bool ignore_unmapped = 3;
  // [optional]
  optional NestedSortValue nested = 4;
  // [optional] Specifies the sort order (asc or dsc) for the score.
  optional SortOrder order = 5;

  // [optional] Specifies the units used to compute sort values. Default is meters (m).
  optional DistanceUnit unit = 6;
  // [optional]
  optional GeoValidationMethod validation_method = 7;
}

enum GeoValidationMethod {
  GEO_VALIDATION_METHOD_UNSPECIFIED = 0;
  GEO_VALIDATION_METHOD_COERCE = 1;
  GEO_VALIDATION_METHOD_IGNORE_MALFORMED = 2;
  GEO_VALIDATION_METHOD_STRICT = 3;
}

enum DistanceUnit {
  DISTANCE_UNIT_UNSPECIFIED = 0;
  DISTANCE_UNIT_CM = 1;
  DISTANCE_UNIT_FT = 2;
  DISTANCE_UNIT_IN = 3;
  DISTANCE_UNIT_KM = 4;
  DISTANCE_UNIT_M = 5;
  DISTANCE_UNIT_MI = 6;
  DISTANCE_UNIT_MM = 7;
  DISTANCE_UNIT_NMI = 8;
  DISTANCE_UNIT_YD = 9;
}

enum ScriptSortType {
  SCRIPT_SORT_TYPE_UNSPECIFIED = 0;
  SCRIPT_SORT_TYPE_NUMBER = 1;
  SCRIPT_SORT_TYPE_STRING = 2;
  SCRIPT_SORT_TYPE_VERSION = 3;
}


message ScriptSort {

  // [optional] Specifies the sort order (asc or dsc) for the score.
  SortOrder order = 1;

  // [optional] The script to execute for custom sorting.
  Script script = 2;

  // [optional] Specifies script sort type.
  ScriptSortType type = 3;
  // [optional] Specifies what array value should be chosen for sorting the document.
  SortMode mode = 4;
  // Supports sorting by fields that are inside one or more nested objects.
  NestedSortValue nested = 5;

}

message NestedSortValue {

  // [optional] A filter that the inner objects inside the nested path should match with in order for its field values to be taken into account by sorting. Common case is to repeat the query / filter inside the nested filter or query. By default no filter is active.
  QueryContainer filter = 1;

  // [optional] The maximum number of children to consider per root document when picking the sort value. Defaults to unlimited.
  int32 max_children = 2;

  // [optional] Same as top-level nested but applies to another nested path within the current nested object.
  NestedSortValue nested = 3;

  // [required] Specifies the path to the field on which to sort.
  string path = 4;

}

message FieldAndFormat {

  // [required] Wildcard pattern. The request returns doc values for field names matching this pattern.
  string field = 1;

  // [optional] Format in which the values are returned.
  optional string format = 2;

  // [optional] Retrieve unmapped fields in an object from _source
  optional bool include_unmapped = 3;

}

message FieldCollapse {

  // [required] The document field by which you want to group or collapse the search results
  string field = 1;

  // [optional] Expanding each group uses an additional query for each inner_hit request for every collapsed hit in the response.
  repeated InnerHits inner_hits = 2;

  // [optional] Use to control the maximum number of concurrent searches allowed in this phase.
  optional int32 max_concurrent_group_searches = 3;

}

message ScriptScoreQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // Documents with a score lower than this floating point number are excluded from the search results.
  float min_score = 3;

  QueryContainer query = 4;

  Script script = 5;

}

message ExistsQuery {
  // [required] Name of the field you wish to search.
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;
}

enum Operator {
  OPERATOR_UNSPECIFIED = 0;
  OPERATOR_AND = 1;
  OPERATOR_OR = 2;
}

message SimpleQueryStringQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // Analyzer used to convert text in the query string into tokens.
  string analyzer = 3;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  bool analyze_wildcard = 4;

  // If `true`, the parser creates a match_phrase query for each multi-position token.
  bool auto_generate_synonyms_phrase_query = 5;

  Operator default_operator = 6;

  repeated string fields = 7;

  PipeSeparatedFlagsSimpleQueryStringFlag flags = 8;

  // Maximum number of terms to which the query expands for fuzzy matching.
  int32 fuzzy_max_expansions = 9;

  // Number of beginning characters left unchanged for fuzzy matching.
  int32 fuzzy_prefix_length = 10;

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool fuzzy_transpositions = 11;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  bool lenient = 12;

  MinimumShouldMatch minimum_should_match = 13;
  // Query string in the simple query string syntax you wish to parse and use for search.
  string query = 14;

  // Suffix appended to quoted text in the query string.
  string quote_field_suffix = 15;

}

message WildcardQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] The name of the query for query tagging.
  optional string x_name = 3;

  // [optional] Allows case insensitive matching of the pattern with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  optional bool case_insensitive = 4;

  optional MultiTermQueryRewrite rewrite = 5;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [optional] Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.
  optional string value = 6;

  // [optional] Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.
  optional string wildcard = 7;

}

message PipeSeparatedFlagsSimpleQueryStringFlag {

  enum SimpleQueryStringFlag {
    SIMPLE_QUERY_STRING_FLAG_UNSPECIFIED = 0;
    SIMPLE_QUERY_STRING_FLAG_ALL = 1;
    SIMPLE_QUERY_STRING_FLAG_AND = 2;
    SIMPLE_QUERY_STRING_FLAG_ESCAPE = 3;
    SIMPLE_QUERY_STRING_FLAG_FUZZY = 4;
    SIMPLE_QUERY_STRING_FLAG_NEAR = 5;
    SIMPLE_QUERY_STRING_FLAG_NONE = 6;
    SIMPLE_QUERY_STRING_FLAG_NOT = 7;
    SIMPLE_QUERY_STRING_FLAG_OR = 8;
    SIMPLE_QUERY_STRING_FLAG_PHRASE = 9;
    SIMPLE_QUERY_STRING_FLAG_PRECEDENCE = 10;
    SIMPLE_QUERY_STRING_FLAG_PREFIX = 11;
    SIMPLE_QUERY_STRING_FLAG_SLOP = 12;
    SIMPLE_QUERY_STRING_FLAG_WHITESPACE = 13;
  }

  oneof pipe_separated_flags_simple_query_string_flag{
    string string_value = 1;
    SimpleQueryStringFlag simple_query_string_flag = 2;
  }

}

message KnnQuery {
  // [required] Specifies the vector field against which to run a search query
  string field = 1;

  // [optional]
  // Query vector. Must have the same number of dimensions as the vector field you are searching against.
  repeated float vector = 2;

  // [optional]
  // The final number of nearest neighbors to return as top hits.
  optional int32 k = 3;

  // [optional]
  // The minimum similarity score for a neighbor to be considered a hit.
  optional float min_score = 4;

  // [optional]
  // The maximum physical distance in vector space for a neighbor to be considered a hit.
  optional float max_distance = 5;

  // [optional]
  // Filters for the kNN search query. The kNN search will return the top k documents that also match this filter. If filter is not provided, all documents are allowed to match.
  optional QueryContainer filter = 6;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 7;

  // [optional] Query name for query tagging.
  optional string x_name = 8;

  // [optional]
  // Method parameters are dependent on the combination of engine and method used to create the index.
  // Available method ef_search see https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#ef_search and nprobes "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#nprobes"
  optional ObjectMap method_parameters = 9;

  // [optional]
  // Available in version later than 2.17
  // To explicitly apply rescoring, provide the rescore parameter in a query on a quantized index and specify the oversample_factor "https://opensearch.org/docs/latest/search-plugins/knn/approximate-knn/#rescoring-quantized-results-using-full-precision"
  optional KnnQueryRescore rescore = 10;

  // [optional] When true, retrieves scores for all nested field documents within each parent document. Used with nested queries. For more information, see Vector search with nested fields.
  optional bool expand_nested_docs = 11;

}

message RescoreContext {
  optional float oversample_factor = 1;
}

message KnnQueryRescore {
  oneof knn_query_rescore {
    bool enable = 1;

    RescoreContext context = 2;
  }
}

message MatchQueryTypeless {
  string field = 1;
  oneof match_query_typeless {
    // Standard match query for performing a full-text search, including options for fuzzy matching.
    MatchQuery match_query = 2;
    // Simplified match query syntax by combining the <field> and query parameters
    ObjectMap object_map = 3;
  }
}

message MatchQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 3;

  // [optional]
  // Specifies whether to create a match phrase query automatically for multi-term synonyms.
  // For example, if you specify ba,batting average as synonyms and search for ba, OpenSearch searches for ba OR "batting average" (if this option is true) or ba OR (batting AND average) (if this option is false).
  // Default is true.
  bool auto_generate_synonyms_phrase_query = 4;

  // [x-deprecated]
  float cutoff_frequency = 5;

  // [optional]
  // The number of character edits (insertions, deletions, substitutions, or transpositions) that it takes to change one word to another when determining whether a term matched a value.
  // For example, the distance between wined and wind is 1. Valid values are non-negative integers or AUTO.
  // The default, AUTO, chooses a value based on the length of each term and is a good choice for most use cases.
  Fuzziness fuzziness = 6;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite fuzzy_rewrite = 7;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [optional]
  // Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option.
  // For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo.
  // The default(true) is a good choice for most use cases.
  bool fuzzy_transpositions = 8;

  // [optional]
  // Setting lenient to true ignores data type mismatches between the query and the document field.
  // For example, a query string of "8.2" could match a field of type float.
  // Default is false.
  bool lenient = 9;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  int32 max_expansions = 10;

  // [optional]
  // If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match.
  // For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  MinimumShouldMatch minimum_should_match = 11;

  // [optional]
  // If the query string contains multiple search terms, whether all terms need to match (AND) or only one term needs to match (OR) for a document to be considered a match.
  // Default is OR.
  Operator operator = 12;

  // [optional]
  // The number of leading characters that are not considered in fuzziness.
  // Default is 0.
  int32 prefix_length = 13;

  message Query {
    oneof query{
      // if the query value is string type.
      string string_value = 1;
      // if the query value is number type.
      GeneralNumber general_number = 2;
      // if the query value is boolean type.
      bool bool_value = 3;
    }
  }

  // [required]
  // The query string to use for search.
  Query query = 14;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string.
  // For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 15;

  enum ZeroTermsQuery {
    ZERO_TERMS_QUERY_UNSPECIFIED = 0;
    // zero_terms_query specifies whether to match all documents (all).
    ZERO_TERMS_QUERY_ALL = 1;
    // zero_terms_query specifies whether to match no documents (none)
    ZERO_TERMS_QUERY_NONE = 2;
  }

}

message BoolQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] The name of the query for query tagging.
  optional string x_name = 2;

  // [optional] The clause (query) must appear in matching documents. However, unlike `must`, the score of the query will be ignored.
  repeated QueryContainer filter = 3;

  // [optional]
  optional MinimumShouldMatch minimum_should_match = 4;

  // [optional]The clause (query) must appear in matching documents and will contribute to the score.
  repeated QueryContainer must = 5;

  // [optional] The clause (query) must not appear in the matching documents. Because scoring is ignored, a score of `0` is returned for all documents.
  repeated QueryContainer must_not = 6;

  // [optional] The clause (query) should appear in the matching document.
  repeated QueryContainer should = 7;

  // [optional] Ensures correct behavior when a query contains only `must_not` clauses. By default set to true, OpenSearch adds a match-all clause to ensure results are returned from Lucene, with the `must_not` conditions applied as filters. If set to false, the query may return no results, as Lucene typically requires at least one positive condition.
  optional bool adjust_pure_negative = 8;
}

message MinimumShouldMatch{
  oneof minimum_should_match{
    // if minimum_should_match is integer type. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    int32 int32_value = 1;
    // if minimum_should_match is string type like percentage or combinations. see "https://opensearch.org/docs/latest/query-dsl/minimum-should-match/#valid-values"
    string string_value = 2;
  }
}

message BoostingQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.
  float negative_boost = 3;

  QueryContainer negative = 4;

  QueryContainer positive = 5;

}

message ConstantScoreQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  QueryContainer filter = 3;

}

message DisMaxQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // One or more query clauses. Returned documents must match one or more of these queries. If a document matches multiple queries, OpenSearch uses the highest relevance score.
  repeated QueryContainer queries = 3;

  // Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.
  float tie_breaker = 4;

}

message FunctionScoreQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  FunctionBoostMode boost_mode = 3;

  enum FunctionBoostMode {
    FUNCTION_BOOST_MODE_UNSPECIFIED = 0;
    FUNCTION_BOOST_MODE_AVG = 1;
    FUNCTION_BOOST_MODE_MAX = 2;
    FUNCTION_BOOST_MODE_MIN = 3;
    FUNCTION_BOOST_MODE_MULTIPLY = 4;
    FUNCTION_BOOST_MODE_REPLACE = 5;
    FUNCTION_BOOST_MODE_SUM = 6;
  }

  // One or more functions that compute a new score for each document returned by the query.
  repeated FunctionScoreContainer functions = 4;

  // Restricts the new score to not exceed the provided limit.
  float max_boost = 5;

  // Excludes documents that do not meet the provided score threshold.
  float min_score = 6;

  QueryContainer query = 7;

  FunctionScoreMode score_mode = 8;

  enum FunctionScoreMode {
    FUNCTION_SCORE_MODE_UNSPECIFIED = 0;
    FUNCTION_SCORE_MODE_AVG = 1;
    FUNCTION_SCORE_MODE_FIRST = 2;
    FUNCTION_SCORE_MODE_MAX = 3;
    FUNCTION_SCORE_MODE_MIN = 4;
    FUNCTION_SCORE_MODE_MULTIPLY = 5;
    FUNCTION_SCORE_MODE_SUM = 6;
  }

}

message IntervalsAllOf {

  // An array of rules to combine. All rules must produce a match in a document for the overall source to match.
  repeated IntervalsContainer intervals = 1;

  // Maximum number of positions between the matching terms. Intervals produced by the rules further apart than this are not considered matches.
  int32 max_gaps = 2;

  // If `true`, intervals produced by the rules should appear in the order in which they are specified.
  bool ordered = 3;

  IntervalsFilter filter = 4;

}

message IntervalsAnyOf {

  // An array of rules to match.
  repeated IntervalsContainer intervals = 1;

  IntervalsFilter filter = 2;

}

message IntervalsMatch {

  // Analyzer used to analyze terms in the query.
  string analyzer = 1;

  // Maximum number of positions between the matching terms. Terms further apart than this are not considered matches.
  int32 max_gaps = 2;

  // If `true`, matching terms must appear in their specified order.
  bool ordered = 3;

  // Text you wish to find in the provided field.
  string query = 4;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 5;

  IntervalsFilter filter = 6;

}

message IntervalsQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  oneof intervals_query {
    IntervalsAllOf all_of = 4;

    IntervalsAnyOf any_of = 5;

    IntervalsFuzzy fuzzy = 6;

    IntervalsMatch match = 7;

    IntervalsPrefix prefix = 8;

    IntervalsWildcard wildcard = 9;
  }

}

message FunctionScoreContainer {
  QueryContainer filter = 1;

  float weight = 2;

  //TODO: add decay function
  oneof function_score_container {

    //   Decay function not supported
    //    DecayFunction exp = 3;
    //
    //    DecayFunction gauss = 4;
    //
    //    DecayFunction linear = 5;

    FieldValueFactorScoreFunction field_value_factor = 6;

    RandomScoreFunction random_score = 7;

    ScriptScoreFunction script_score = 8;
  }

}

message ScriptScoreFunction {

  Script script = 1;

}

message IntervalsFilter {
  oneof intervals_filter {
    IntervalsContainer after = 1;

    IntervalsContainer before = 2;

    IntervalsContainer contained_by = 3;

    IntervalsContainer containing = 4;

    IntervalsContainer not_contained_by = 5;

    IntervalsContainer not_containing = 6;

    IntervalsContainer not_overlapping = 7;

    IntervalsContainer overlapping = 8;

    Script script = 9;
  }

}

message IntervalsContainer {

  oneof intervals_container {
    IntervalsAllOf all_of = 1;

    IntervalsAnyOf any_of = 2;

    IntervalsFuzzy fuzzy = 3;

    IntervalsMatch match = 4;

    IntervalsPrefix prefix = 5;

    IntervalsWildcard wildcard = 6;
  }

}

message PrefixQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite rewrite = 4;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [required]
  // The term to search for in the field specified in <field>.
  string value = 5;

  // [optional]
  // Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. Default is `false` which means the case sensitivity of matching depends on the underlying field's mapping.
  bool case_insensitive = 6;

}

message TermsLookupFieldStringArrayMap {
  oneof terms_lookup_field_string_array_map {
    // terms_lookup_field terms you wish to find in the provided field
    TermsLookupField terms_lookup_field = 1;
    // string_array terms value you wish to find in the provided field
    StringArray string_array = 2;
  }
}

enum ValueType {
    VALUE_TYPE_UNSPECIFIED = 0;
    VALUE_TYPE_BITMAP = 1;
    VALUE_TYPE_DEFAULT = 2;
}

enum TermsQueryValueType {
  TERMS_QUERY_VALUE_TYPE_UNSPECIFIED = 0;
  TERMS_QUERY_VALUE_TYPE_BITMAP = 1;
  TERMS_QUERY_VALUE_TYPE_DEFAULT = 2;
}

message TermsQueryField {
  oneof terms_query_field {
    FieldValueArray field_value_array = 1;

    TermsLookup lookup = 2;
  }
}

message TermsLookup {
  string index = 1;

  // The unique identifier for a resource.
  string id = 2;

  // The path to a field or an array of paths. Some APIs support wildcards in the path, which allows you to select multiple fields.
  string path = 3;

  // The routing value for the document.
  optional string routing = 4;

  optional bool store = 5;
}

message FieldValueArray {
  repeated FieldValue field_value_array = 1;
}

message TermsLookupField {

  // [required]
  // The name of the index from which to fetch field values
  string index = 1;

  // [required]
  // The document ID of the document from which to fetch field values.
  string id = 2;

  // [required]
  // The name of the field from which to fetch field values. Specify nested fields using dot path notation
  string path = 3;

  // [optional]
  // Custom routing value of the document from which to fetch term values. If a custom routing value was provided when the document was indexed, this parameter is required.
  optional string routing = 4;

  // [optional]
  optional bool store = 5;

}

message TermsSetQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  // [optional]
  // The name of the numeric field that specifies the number of matching terms required in order to return a document in the results.
  string minimum_should_match_field = 4;

  // [optional]
  // A script that returns the number of matching terms required in order to return a document in the results.
  Script minimum_should_match_script = 5;

  // [required]
  // The array of terms to search for in the field specified in <field>. A document is returned in the results only if the required number of terms matches the document's field values exactly, with the correct spacing and capitalization.
  repeated string terms = 6;

}

message TermQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  // [required]
  // Term you wish to find in the provided <field>. To return a document, the term must exactly match the field value, including whitespace and capitalization.
  FieldValue value = 4;

  // [optional]
  // Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`. When `false`, the case sensitivity of matching depends on the underlying field's mapping.
  optional bool case_insensitive = 5;

}


message QueryStringQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  bool allow_leading_wildcard = 3;

  // Analyzer used to convert text in the query string into tokens.
  string analyzer = 4;

  // If `true`, the query attempts to analyze wildcard terms in the query string.
  bool analyze_wildcard = 5;

  // If `true`, match phrase queries are automatically created for multi-term synonyms.
  bool auto_generate_synonyms_phrase_query = 6;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string default_field = 7;

  Operator default_operator = 8;

  // If `true`, enable position increments in queries constructed from a `query_string` search.
  bool enable_position_increments = 9;

  bool escape = 10;

  repeated string fields = 11;

  Fuzziness fuzziness = 12;

  // Maximum number of terms to which the query expands for fuzzy matching.
  int32 fuzzy_max_expansions = 13;

  // Number of beginning characters left unchanged for fuzzy matching.
  int32 fuzzy_prefix_length = 14;

  MultiTermQueryRewrite fuzzy_rewrite = 15;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool fuzzy_transpositions = 16;

  // If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.
  bool lenient = 17;

  // Maximum number of automaton states required for the query.
  int32 max_determinized_states = 18;

  MinimumShouldMatch minimum_should_match = 19;

  // Maximum number of positions allowed between matching tokens for phrases.
  int32 phrase_slop = 20;

  // Query string you wish to parse and use for search.
  string query = 21;

  // Analyzer used to convert quoted text in the query string into tokens. For quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.
  string quote_analyzer = 22;

  // Suffix appended to quoted text in the query string. You can use this suffix to use a different analysis method for exact matches.
  string quote_field_suffix = 23;

  MultiTermQueryRewrite rewrite = 24;

  // How to combine the queries generated from the individual search terms in the resulting `dis_max` query.
  float tie_breaker = 25;

  string time_zone = 26;

  TextQueryType type = 27;
  enum TextQueryType {
    TEXT_QUERY_TYPE_UNSPECIFIED = 0;
    TEXT_QUERY_TYPE_BEST_FIELDS = 1;
    TEXT_QUERY_TYPE_BOOL_PREFIX = 2;
    TEXT_QUERY_TYPE_CROSS_FIELDS = 3;
    TEXT_QUERY_TYPE_MOST_FIELDS = 4;
    TEXT_QUERY_TYPE_PHRASE = 5;
    TEXT_QUERY_TYPE_PHRASE_PREFIX = 6;
  }

}

message RandomScoreFunction {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  message Seed {
    oneof seed {
      int32 int32_value = 1;
      string string_value = 2;
    }
  }
  Seed seed = 2;
}

// TODO: need to revisit RangeQuery def
message RangeQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  oneof range_query{
    DateRangeQuery date_range_query = 2;
    NumberRangeQuery number_range_query = 3;
  }
}

message RegexpQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [required] Regular expression for terms you wish to find in the provided field.
  string value = 2;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 3;

  // [optional] Query name for query tagging
  optional string x_name = 4;

  // [optional] If true, allows case-insensitive matching of the regular expression value with the indexed field values. Default is false (case sensitivity is determined by the field’s mapping).
  optional bool case_insensitive = 5;

  // [optional] Enables optional operators for the regular expression.
  optional string flags = 6;

  // [optional] Lucene converts a regular expression to an automaton with a number of determinized states. This parameter specifies the maximum number of automaton states the query requires. Use this parameter to prevent high resource consumption. To run complex regular expressions, you may need to increase the value of this parameter. Default is 10,000.
  optional int32 max_determinized_states = 7;

  // [optional] Determines how OpenSearch rewrites and scores multi-term queries. Valid values are constant_score, scoring_boolean, constant_score_boolean, top_terms_N, top_terms_boost_N, and top_terms_blended_freqs_N. Default is constant_score.
  optional MultiTermQueryRewrite rewrite = 8;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }
}

message DateRangeQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  RangeRelation relation = 3;
  enum RangeRelation {
    RANGE_RELATION_UNSPECIFIED = 0;
    RANGE_RELATION_CONTAINS = 1;
    RANGE_RELATION_INTERSECTS = 2;
    RANGE_RELATION_WITHIN = 3;
  }

  string gt = 4;

  string gte = 5;

  string lt = 6;

  string lte = 7;

  message From {
    oneof from {
      string string_value = 1;
      NullValue null_value = 2;
    }
  }

  From from = 8;

  message To {
    oneof to {
      string string_value = 1;
      NullValue null_value = 2;
    }
  }
  To to = 9;

  string format = 10;

  string time_zone = 11;

}

message NumberRangeQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  RangeRelation relation = 3;
  enum RangeRelation {
    RANGE_RELATION_UNSPECIFIED = 0;
    RANGE_RELATION_CONTAINS = 1;
    RANGE_RELATION_INTERSECTS = 2;
    RANGE_RELATION_WITHIN = 3;
  }


  // Greater than.
  GeneralNumber gt = 4;

  // Greater than or equal to.
  GeneralNumber gte = 5;

  // Less than.
  GeneralNumber lt = 6;

  // Less than or equal to.
  GeneralNumber lte = 7;

  message From {
    oneof from {
      string string_value = 1;
      GeneralNumber general_number = 2;
      NullValue null_value = 3;
    }
  }
  From from = 8;

  message To {
    oneof to {
      string string_value = 1;
      GeneralNumber general_number = 2;
      NullValue null_value = 3;
    }
  }
  To to = 9;
}

message FuzzyQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries "expand to" a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  int32 max_expansions = 4;

  // [optional]
  // The number of leading characters that are not considered in fuzziness. Default is 0.
  int32 prefix_length = 5;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite rewrite = 6;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }
  // [optional]
  // Specifies whether to allow transpositions of two adjacent characters (ab to ba) as edits. Default is true.
  bool transpositions = 7;
  // [optional]
  // The number of character edits (insert, delete, substitute) needed to change one word to another when determining whether a term matched a value.
  Fuzziness fuzziness = 8;

  message Value {
    oneof value {
      string string_value = 1;
      bool bool_value = 2;
      GeneralNumber general_number = 3;
    }
  }

  // [required]
  // Term you wish to find in the provided <field>.
  Value value = 9;
}

message Fuzziness{

  oneof fuzziness{
    // AUTO: Generates an edit distance based on the length of the term. Low and high distance arguments may be optionally provided AUTO:[low],[high]. AUTO should generally be the preferred value for fuzziness.
    string string_value = 1;
    // 0,1,2: The maximum allowed Levenshtein Edit Distance (or number of edits)
    int32 int32_value = 2;
  }

}

message FieldValue {
  optional bool bool = 1;

  optional GeneralNumber general_number = 2;

  optional string string = 3;

  optional NullValue null_value = 4;
}

message IdsQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  repeated string values = 3;

}

message IntervalsFuzzy {

  // Analyzer used to normalize the term.
  string analyzer = 1;

  Fuzziness fuzziness = 2;

  // Number of beginning characters left unchanged when creating expansions.
  int32 prefix_length = 3;

  // The term to match.
  string term = 4;

  // Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).
  bool transpositions = 5;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 6;

}

message IntervalsPrefix {

  // Analyzer used to analyze the `prefix`.
  string analyzer = 1;

  // Beginning characters of terms you wish to find in the top-level field.
  string prefix = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 3;

}

message IntervalsWildcard {

  // Analyzer used to analyze the `pattern`. Defaults to the top-level field's analyzer.
  string analyzer = 1;

  // Wildcard pattern used to find matching terms.
  string pattern = 2;

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string use_field = 3;

}

message MatchAllQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;
}

message MatchBoolPrefixQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] Query name for query tagging.
  optional string x_name = 3;

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 4;

  // [optional]
  // The number of character edits (insert, delete, substitute) that it takes to change one word to another when determining whether a term matched a value.
  // For example, the distance between wined and wind is 1.
  // The default, AUTO, chooses a value based on the length of each term and is a good choice for most use cases.
  Fuzziness fuzziness = 5;

  // [optional]
  // Determines how OpenSearch rewrites the query.
  // Default is constant_score.
  MultiTermQueryRewrite fuzzy_rewrite = 6;
  enum MultiTermQueryRewrite {
    MULTI_TERM_QUERY_REWRITE_UNSPECIFIED = 0;
    // Uses the constant_score_boolean method for fewer matching terms. Otherwise, this method finds all matching terms in sequence and returns matching documents using a bit set.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE = 1;
    // Assigns each document a relevance score equal to the boost parameter.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, opensearch returns an error.
    MULTI_TERM_QUERY_REWRITE_CONSTANT_SCORE_BOOLEAN = 2;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. This method can cause the final bool query to exceed the clause limit in the indices.query.bool.max_clause_count setting. If the query exceeds this limit, Elasticsearch returns an error.
    MULTI_TERM_QUERY_REWRITE_SCORING_BOOLEAN = 3;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_N = 4;
    // Calculates a relevance score for each matching document as if all terms had the same frequency. This frequency is the maximum frequency of all matching terms.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BLENDED_FREQS_N = 5;
    // Calculates a relevance score for each matching document.
    // This method changes the original query to a bool query. This bool query contains a should clause and term query for each matching term. The final bool query only includes term queries for the top N scoring terms. You can use this method to avoid exceeding the clause limit in the indices.query.bool.max_clause_count setting.
    MULTI_TERM_QUERY_REWRITE_TOP_TERMS_BOOST_N = 6;
  }

  // [optional]
  // Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option.
  // For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo.
  // The default(true) is a good choice for most use cases.
  bool fuzzy_transpositions = 7;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  int32 max_expansions = 8;

  // [optional]
  // If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match.
  // For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches.
  MinimumShouldMatch minimum_should_match = 9;

  // [optional]
  // If the query string contains multiple search terms, whether all terms need to match (and) or only one term needs to match (or) for a document to be considered a match.
  // Default is or.
  Operator operator = 10;

  // [optional]
  // The number of leading characters that are not considered in fuzziness.
  // Default is 0.
  int32 prefix_length = 11;

  // [required]
  // Terms you wish to find in the provided field. The last term is used in a prefix query.
  string query = 12;

}

message MatchNoneQuery {

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;
}


enum ZeroTermsQuery {
  ZERO_TERMS_QUERY_UNSPECIFIED = 0;
  // zero_terms_query specifies whether to match all documents (all).
  ZERO_TERMS_QUERY_ALL = 1;
  // zero_terms_query specifies whether to match no documents (none)
  ZERO_TERMS_QUERY_NONE = 2;
}

message MatchPhrasePrefixQuery {
  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 1;

  // [optional] Query name for query tagging.
  optional string x_name = 2;

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 3;

  // [optional]
  // The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms.
  // Default is 50.
  int32 max_expansions = 4;

  // [required]
  // The query string to use for search
  string query = 5;

  // [optional]
  // Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase.
  // For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  int32 slop = 6;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 7;

}

message MatchPhraseQuery {
  // [required] Specifies the field against which to run a search query
  string field = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] The name of the query for query tagging.
  optional string x_name = 3;

  // [optional]
  // The analyzer used to tokenize the query string text.
  // Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index.
  string analyzer = 4;

  // [required]
  // The query string to use for search.
  string query = 5;

  // [optional]
  // Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase. For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.”
  int32 slop = 6;

  // [optional]
  // In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all.
  // Default is none.
  ZeroTermsQuery zero_terms_query = 7;

}

message MultiMatchQuery {
  // [required] The query string to use for search.
  string query = 1;

  // [optional] Floating point number used to decrease or increase the relevance scores of the query. Boost values are relative to the default value of 1.0. A boost value between 0 and 1.0 decreases the relevance score. A value greater than 1.0 increases the relevance score.
  optional float boost = 2;

  // [optional] The name of the query for query tagging.
  optional string x_name = 3;

  // [optional] The analyzer used to tokenize the query string text. Default is the index-time analyzer specified for the default_field. If no analyzer is specified for the default_field, the analyzer is the default analyzer for the index. For more information about index.query.default_field, see Dynamic index-level index settings.
  optional string analyzer = 4;

  // [optional] Specifies whether to create a match phrase query automatically for multi-term synonyms. For example, if you specify ba,batting average as synonyms and search for ba, OpenSearch searches for ba OR "batting average" (if this option is true) or ba OR (batting AND average) (if this option is false). Default is true.
  optional bool auto_generate_synonyms_phrase_query = 5;

  // [optional] The list of fields in which to search. If you don’t provide the fields parameter, multi_match query searches the fields specified in the index.query.default_field setting, which defaults to *.
  repeated string fields = 6;

  // [optional] Determines how OpenSearch rewrites the query. Valid values are constant_score, scoring_boolean, constant_score_boolean, top_terms_N, top_terms_boost_N, and top_terms_blended_freqs_N. If the fuzziness parameter is not 0, the query uses a fuzzy_rewrite method of top_terms_blended_freqs_${max_expansions} by default. Default is constant_score.
  optional string fuzzy_rewrite = 7;

  // [optional] Setting fuzzy_transpositions to true (default) adds swaps of adjacent characters to the insert, delete, and substitute operations of the fuzziness option. For example, the distance between wind and wnid is 1 if fuzzy_transpositions is true (swap “n” and “i”) and 2 if it is false (delete “n”, insert “n”). If fuzzy_transpositions is false, rewind and wnid have the same distance (2) from wind, despite the more human-centric opinion that wnid is an obvious typo. The default is a good choice for most use cases.
  optional bool fuzzy_transpositions = 8;

  // [optional] Setting lenient to true ignores data type mismatches between the query and the document field. For example, a query string of "8.2" could match a field of type float. Default is false.
  optional bool lenient = 9;

  // [optional] The maximum number of terms to which the query can expand. Fuzzy queries “expand to” a number of matching terms that are within the distance specified in fuzziness. Then OpenSearch tries to match those terms. Default is 50.
  optional int32 max_expansions = 10;

  // [optional] If the query string contains multiple search terms and you use the or operator, the number of terms that need to match for the document to be considered a match. For example, if minimum_should_match is 2, wind often rising does not match The Wind Rises. If minimum_should_match is 1, it matches. For details, see Minimum should match.

  optional MinimumShouldMatch minimum_should_match = 11;

  // [optional] If the query string contains multiple search terms, whether all terms need to match (AND) or only one term needs to match (OR) for a document to be considered a match. Valid values are: 1) OR: The string to be is interpreted as to OR be. 2) AND: The string to be is interpreted as to AND be. Default is OR.
  optional Operator operator = 12;

  // [optional] The number of leading characters that are not considered in fuzziness. Default is 0.
  optional int32 prefix_length = 13;

  // [optional] Controls the degree to which words in a query can be misordered and still be considered a match. From the Lucene documentation: “The number of other words permitted between words in query phrase. For example, to switch the order of two words requires two moves (the first move places the words atop one another), so to permit reorderings of phrases, the slop must be at least two. A value of zero requires an exact match.” Supported for phrase and phrase_prefix query types.
  optional int32 slop = 14;

  // [optional] A factor between 0 and 1.0 that is used to give more weight to documents that match multiple query clauses. For more information, see The tie_breaker parameter`.
  optional float tie_breaker = 15;

  // [optional] The multi-match query type. Valid values are best_fields, most_fields, cross_fields, phrase, phrase_prefix, bool_prefix. Default is best_fields.
  optional TextQueryType type = 16;
  enum TextQueryType {
    TEXT_QUERY_TYPE_UNSPECIFIED = 0;
    TEXT_QUERY_TYPE_BEST_FIELDS = 1;
    TEXT_QUERY_TYPE_BOOL_PREFIX = 2;
    TEXT_QUERY_TYPE_CROSS_FIELDS = 3;
    TEXT_QUERY_TYPE_MOST_FIELDS = 4;
    TEXT_QUERY_TYPE_PHRASE = 5;
    TEXT_QUERY_TYPE_PHRASE_PREFIX = 6;
  }

  // [optional] In some cases, the analyzer removes all terms from a query string. For example, the stop analyzer removes all terms from the string an but this. In those cases, zero_terms_query specifies whether to match no documents (none) or all documents (all). Valid values are none and all. Default is none.
  optional ZeroTermsQuery zero_terms_query = 17;
  enum ZeroTermsQuery {
    ZERO_TERMS_QUERY_UNSPECIFIED = 0;
    ZERO_TERMS_QUERY_ALL = 1;
    ZERO_TERMS_QUERY_NONE = 2;
  }
}

message FieldValueFactorScoreFunction {

  // Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.
  string field = 1;

  // Optional factor to multiply the field value with.
  float factor = 2;

  // Value used if the document doesn't have that field. The modifier and factor are still applied to it as though it were read from the document.
  double missing = 3;

  FieldValueFactorModifier modifier = 4;

  enum FieldValueFactorModifier {
    FIELD_VALUE_FACTOR_MODIFIER_UNSPECIFIED = 0;
    FIELD_VALUE_FACTOR_MODIFIER_LN = 1;
    FIELD_VALUE_FACTOR_MODIFIER_LN1P = 2;
    FIELD_VALUE_FACTOR_MODIFIER_LN2P = 3;
    FIELD_VALUE_FACTOR_MODIFIER_LOG = 4;
    FIELD_VALUE_FACTOR_MODIFIER_LOG1P = 5;
    FIELD_VALUE_FACTOR_MODIFIER_LOG2P = 6;
    FIELD_VALUE_FACTOR_MODIFIER_NONE = 7;
    FIELD_VALUE_FACTOR_MODIFIER_RECIPROCAL = 8;
    FIELD_VALUE_FACTOR_MODIFIER_SQRT = 9;
    FIELD_VALUE_FACTOR_MODIFIER_SQUARE = 10;
  }

}

message DutchAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_DUTCH = 1;
  }
  Type type = 1;

  repeated string stopwords = 2;
}

message FingerprintAnalyzer {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_FINGERPRINT = 1;
  }
  Type type = 1;

  string version = 2;

  float max_output_size = 3;

  bool preserve_original = 4;

  string separator = 5;

  // Language value, such as _arabic_ or _thai_. Defaults to _english_. Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words. Also accepts an array of stop words.
  repeated string stopwords = 6;

  string stopwords_path = 7;
}

message IcuAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_ICU_ANALYZER = 1;
  }
  Type type = 1;

  enum IcuNormalizationType {
    ICU_NORMALIZATION_TYPE_UNSPECIFIED = 0;
    ICU_NORMALIZATION_TYPE_NFC = 1;
    ICU_NORMALIZATION_TYPE_NFKC = 2;
    ICU_NORMALIZATION_TYPE_NFKC_CF = 3;
  }
  IcuNormalizationType method = 2;

  enum IcuNormalizationMode {
    ICU_NORMALIZATION_MODE_UNSPECIFIED = 0;
    ICU_NORMALIZATION_MODE_COMPOSE = 1;
    ICU_NORMALIZATION_MODE_DECOMPOSE = 2;
  }

  IcuNormalizationMode mode = 3;
}

//manual generate
message KeywordAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_KEYWORD = 1;
  }
  Type type = 1;

  string version = 2;
}

message KuromojiAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_KUROMOJI = 1;
  }
  Type type = 1;


  enum Mode {
    MODE_UNSPECIFIED = 0;
    MODE_EXTENDED = 1;
    MODE_NORMAL = 2;
    MODE_SEARCH = 3;
  }

  Mode mode = 2;

  string user_dictionary = 3;
}


message LanguageAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_LANGUAGE = 1;
  }
  Type type = 1;

  string version = 2;

  enum Language {
    LANGUAGE_UNSPECIFIED = 0;
    LANGUAGE_ARABIC = 1;
    LANGUAGE_ARMENIAN = 2;
    LANGUAGE_BASQUE = 3;
    LANGUAGE_BRAZILIAN = 4;
    LANGUAGE_BULGARIAN = 5;
    LANGUAGE_CATALAN = 6;
    LANGUAGE_CHINESE = 7;
    LANGUAGE_CJK = 8;
    LANGUAGE_CZECH = 9;
    LANGUAGE_DANISH = 10;
    LANGUAGE_DUTCH = 11;
    LANGUAGE_ENGLISH = 12;
    LANGUAGE_ESTONIAN = 13;
    LANGUAGE_FINNISH = 14;
    LANGUAGE_FRENCH = 15;
    LANGUAGE_GALICIAN = 16;
    LANGUAGE_GERMAN = 17;
    LANGUAGE_GREEK = 18;
    LANGUAGE_HINDI = 19;
    LANGUAGE_HUNGARIAN = 20;
    LANGUAGE_INDONESIAN = 21;
    LANGUAGE_IRISH = 22;
    LANGUAGE_ITALIAN = 23;
    LANGUAGE_LATVIAN = 24;
    LANGUAGE_NORWEGIAN = 25;
    LANGUAGE_PERSIAN = 26;
    LANGUAGE_PORTUGUESE = 27;
    LANGUAGE_ROMANIAN = 28;
    LANGUAGE_RUSSIAN = 29;
    LANGUAGE_SORANI = 30;
    LANGUAGE_SPANISH = 31;
    LANGUAGE_SWEDISH = 32;
    LANGUAGE_THAI = 33;
    LANGUAGE_TURKISH = 34;
  }

  Language language = 3;

  repeated string stem_exclusion = 4;

  // Language value, such as _arabic_ or _thai_. Defaults to _english_. Each language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words. Also accepts an array of stop words.
  repeated string stopwords = 5;

  string stopwords_path = 6;

}

message NoriAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_NORI = 1;
  }
  Type type = 1;

  string version = 2;

  enum NoriDecompoundMode {
    NORI_DECOMPOUND_MODE_UNSPECIFIED = 0;
    NORI_DECOMPOUND_MODE_NONE = 1;
    NORI_DECOMPOUND_MODE_DISCARD = 2;
    NORI_DECOMPOUND_MODE_MIXED = 3;
  }

  NoriDecompoundMode decompound_mode = 3;

  repeated string stoptags = 4;

  string user_dictionary = 5;
}

message PatternAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_PATTERN = 1;
  }
  Type type = 1;

  string version = 2;

  string flags = 3;

  bool lowercase = 4;

  string pattern = 5;

  repeated string stopwords = 6;

}

message SimpleAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_SIMPLE = 1;
  }
  Type type = 1;

  string version = 2;
}

message SnowballAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_SNOWBALL = 1;
  }
  Type type = 1;

  string version = 2;

  enum SnowballLanguage {
    SNOWBALL_LANGUAGE_UNSPECIFIED = 0;
    SNOWBALL_LANGUAGE_ARMENIAN = 1;
    SNOWBALL_LANGUAGE_BASQUE = 2;
    SNOWBALL_LANGUAGE_CATALAN = 3;
    SNOWBALL_LANGUAGE_DANISH = 4;
    SNOWBALL_LANGUAGE_DUTCH = 5;
    SNOWBALL_LANGUAGE_ENGLISH = 6;
    SNOWBALL_LANGUAGE_FINNISH = 7;
    SNOWBALL_LANGUAGE_FRENCH = 8;
    SNOWBALL_LANGUAGE_GERMAN = 9;
    SNOWBALL_LANGUAGE_GERMAN2 = 10;
    SNOWBALL_LANGUAGE_HUNGARIAN = 11;
    SNOWBALL_LANGUAGE_ITALIAN = 12;
    SNOWBALL_LANGUAGE_KP = 13;
    SNOWBALL_LANGUAGE_LOVINS = 14;
    SNOWBALL_LANGUAGE_NORWEGIAN = 15;
    SNOWBALL_LANGUAGE_PORTER = 16;
    SNOWBALL_LANGUAGE_PORTUGUESE = 17;
    SNOWBALL_LANGUAGE_ROMANIAN = 18;
    SNOWBALL_LANGUAGE_RUSSIAN = 19;
    SNOWBALL_LANGUAGE_SPANISH = 20;
    SNOWBALL_LANGUAGE_SWEDISH = 21;
    SNOWBALL_LANGUAGE_TURKISH = 22;
  }

  SnowballLanguage language = 3;

  repeated string stopwords = 4;
}

message StandardAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_STANDARD = 1;
  }
  Type type = 1;

  float max_token_length = 2;
  repeated string stopwords = 3;
}

message StopAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_STOP = 1;
  }
  Type type = 1;

  string version = 2;

  repeated string stopwords = 3;

  string stopwords_path = 4;
}

message WhitespaceAnalyzer{
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_WHITESPACE = 1;
  }
  Type type = 1;

  string version = 2;

}

message CustomAnalyzer {
  enum Type {
    TYPE_UNSPECIFIED = 0;
    TYPE_CUSTOM = 1;
  }

  Type type = 1;

  repeated string char_filter = 2;

  repeated string filter = 3;

  float position_increment_gap = 4;

  float position_offset_gap = 5;

  string tokenizer = 6;
}

message Analyzer {
  oneof analyzer {
    CustomAnalyzer custom_analyzer = 1;
    FingerprintAnalyzer fingerprint_analyzer = 2;
    KeywordAnalyzer keyword_analyzer = 3;
    LanguageAnalyzer language_analyzer = 4;
    NoriAnalyzer nori_analyzer = 5;
    PatternAnalyzer pattern_analyzer = 6;
    SimpleAnalyzer simple_analyzer = 7;
    StandardAnalyzer standard_analyzer = 8;
    StopAnalyzer stop_analyzer = 9;
    WhitespaceAnalyzer whitespace_analyzer = 10;
    IcuAnalyzer icu_analyzer = 11;
    KuromojiAnalyzer kuromoji_analyzer = 12;
    SnowballAnalyzer snowball_analyzer = 13;
    DutchAnalyzer dutch_analyzer = 14;
  }
}

message Error {
  oneof version {
    OpenSearchExceptionV1 v1 = 1;
  }
}


message OpenSearchExceptionV1 {
  string type = 1;
  string reason = 2;
  repeated .google.protobuf.Struct root_cause = 3;

  .google.protobuf.Struct caused_by = 4;
  string stack_trace = 5;
  .google.protobuf.Struct suppressed = 6;

  .google.protobuf.Struct additional_details = 7;
}

message InlineGet {

  .google.protobuf.Struct fields = 1;

  bool found = 2;

  int64 x_seq_no = 3;

  int64 x_primary_term = 4;

  repeated string x_routing = 5;

  oneof inline_get_source {

    // struct_source field to be returned upon explicit request by user
    .google.protobuf.Struct struct_source = 6;

    // Use bytes for better latency/performance, as it reduces payload size over the wire
    bytes x_source = 7;

  }
}
